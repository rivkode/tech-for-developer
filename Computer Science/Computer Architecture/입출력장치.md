아래 내용은 [강민철](https://github.com/kangtegong)님의

- [『혼자 공부하는 컴퓨터 구조+운영체제』 책](https://m.hanbit.co.kr/media/books/book_view.html?p_code=B9177037040)
- [『혼자 공부하는 컴퓨터 구조+운영체제』 유튜브](https://www.youtube.com/watch?v=bls_GjX-4U8&list=PLVsNizTWUw7FCS83JhC1vflK8OcLRG0Hl)

를 참고하였습니다.

<br>


# 입출력장치

## 학습목표
- 장치 컨트롤러에 대해 이해합니다
- 장치 드라이버에 대해 이해합니다
- 프로그램 입출력 방식이 무엇인지 이해합니다
- 인터럽트 기반의 입출력 방식을 이해합니다
- DMA 입출력 방식을 이해합니다

컴퓨터에는 CPU, 메모리뿐만 아니고 모니터, 키보드, 마우스 등과 같은 입출력 장치와 USB 메모리 등 보조 기억장치가 컴퓨터에는 존재합니다.

이러한 외부 장비들과 컴퓨터 내부와 어떻게 연결이 되고 소통하는지를 알아보는 시간을 갖겠습니다.

## 장치 컨트롤러

**입출력장치에는 종류가 너무 많습니다**

입출력 장치에는 키보드, 모니터, USB, 마우스, 스피커 등 매우 많습니다. 그리고 이러한 장치들은 정보를 주고 받는 방식이 다릅니다.

**일반적으로 CPU와 메모리의 데이터 전송률은 높지만 입출력장치의 데이터 전송률은 낮습니다.**

**전송률**(transfer rate)이란 데이터를 얼마나 빨리 교환할 수 있는지를 나타내는 지표입니다.

CPU와 메모리는 전송률이 높아 짧은 시간안에 수많은 데이터를 주고 받을 수 있지만

반면에 키보드, 마우스 등은 상대적으로 짧은시간안에 많은 데이터를 주고 받기는 어렵습니다.

이러한 전송률의 차이는 CPU와 메모리, 입출력 장치 간의 통신을 어렵게 합니다.

전송률에 차이가 나는 이유로 입출력장치는 컴퓨터에 직접 연결되지 않고 장치 컨트롤러(device controller)라는 하드웨어를 통해 연결됩니다.

`입출력 장치는 장치 컨트롤러를 통해 컴퓨터 내부와 정보를 주고 받습니다`

장치 컨트롤러는 입출력 제어기, 입출력 모듈 등으로 다양하게 불리기도 합니다

장치 컨트롤러는 아래와 같은 역할을 통해 위 전송률의 문제를 해결합니다
- CPU와 입출력 장치간의 통신 중개
- 오류 검출
- 데이터 버퍼링

입출력 장치들이 서로 다른 방식으로 데이터를 주고 받아 정보에 대한 약속, 규격화가 어려웠지만 장치 컨트롤러가 일종의 번역가 역할을 하므로써 해결할 수 있습니다

`데이터 버퍼링`

버퍼링이란 전송률이 높은 장치와 낮은 장치 사이에 주고 받는 데이터를 버퍼(Buffer)라는 임시 저장 공간에 저장하여 전송률을 비슷하게 맞추는 방법입니다

버퍼링은 **버퍼에 데이터를 조금씩 모았다가 한꺼번에 내보내거나, 데이터를 한 번에 많이 받아 조금씩 내보내는 방법** 이라고 보면 됩니다

장치 컨트롤러의 간략한 내부 구조를 살펴보겠습니다

- 데이터 레지스터
- 상태 레지스터
- 제어 레지스터

![image](https://user-images.githubusercontent.com/109144975/235444262-a710e580-edc6-4a9d-9c93-f393b8674507.png)


데이터 레지스터
- CPU와 입출력 장치 사이에 주고받는 데이터가 담기는 레지스터
- 데이터 버퍼링 전송률 차이 완화 버퍼 역할

상태 레지스터
- 입출력 장치가 입출력 작업을 할 준비가 되었는지
- 입출력 작업이 완료 되었는지
- 입출력 작업에 오류는 없는지

제어 레지스터
- 입출력 장치가 수행할 내용에 대한 정보와 명령 저장

위 레지스터에 담긴 값들은 버스를 타고 CPU나 다른 입출력 장치로 전달되기도 하고, 장치 컨트롤러에 연결된 입출력 장치로 전달됩니다

## 장치 드라이버

장치 컨트롤러의 동작을 감지하고 제어함으로써 장치 컨트롤러가 컴퓨터 내부와 정보를 주고 받을 수 있게 하는 프로그램

장치 컨트롤러가 입출력 장치를 연결하기 위한 하드웨어적 통로라면,

장치 드라이버는 입출력 장치를 연결하기 위한 소프트웨어적인 통로

컴퓨터가 연결된 장치의 드라이버를 인식하고 실행할 수 있다면 그 장치는 어떤회사인지 관계없이 컴퓨터 내부와 정보를 주고 받을 수 있음

장치 드라이버를 인식하고 실행하는 주체 : 윈도우, 맥 과 같은 운영체제

운영체제가 장치 드라이버를 인식하고 실행할 수 있다면 컴퓨터 내부와 정보를 주고 받을 수 있음

## 마무리

- 입출력장치는 **장치 컨트롤러**를 통해 컴퓨터 내부와 정보를 주고 받습니다
- **장치 드라이버**는 장치 컨트롤러가 컴퓨터 내부와 정보를 주고 받을 수 있게 하는 프로그램입니다

## 다양한 입출력 방법

입출력 작업을 수행하기 위해 CPU와 장치 컨트롤러가 정보를 주고 받아야 합니다. 장치 컨트롤러와 CPU는 어떻게 정보를 주고 받을까요 ?

- 프로그램 입출력
- 입터럽트 기반 입출력
- DMA 입출력

이 있습니다

![image](https://user-images.githubusercontent.com/109144975/235360658-d37dbe81-25a1-4506-8fb4-65404fe0708d.png)

## 프로그램 입출력

프로그램 속 명령어로 입출력 장치를 제어하는 방법입니다

CPU가 프로그램 속 명령어를 실행하는 과정에서 입출력 명령어를 만나면 CPU는 입출력 장치에 연결된 장치 컨트롤러와 상호 작용을 하며 입출력 작업을 수행합니다

CPU는 대략 아래 과정으로 입출력 작업을 수행합니다

1. '메모리에 저장된 정보를 하드 디스크에 백업한다'는 말은 '하드 디스크에 새로운 정보를 쓴다'는 말과 같습니다 CPU는 하드 디스크 컨트롤러의
제어 레지스터에 쓰기 명령을 보냅니다

![image](https://user-images.githubusercontent.com/109144975/235444688-210f9d36-208c-468f-b22c-717aa5f68b4b.png)


2. 하드 디스크 컨트롤러는 하드 디스크 상태를 확인합니다 하드 디스크가 준비된 상태라면 하드 디스크 컨트롤러는 상태 레지스터에 준비되었다고 표시합니다


![image](https://user-images.githubusercontent.com/109144975/235444815-a11565fd-092c-446d-8e61-8edc6494d5a9.png)

3. (a) CPU는 상태 레지스터를 주기적으로 읽어보며 하드 디스크의 준비 여부를 확인합니다 (b)하드 디스크가 준비 됐음으로 CPU가 알게 되면 백업할 
메모리의 정보를 데이터 레지스터에 씁니다 아직 백업 작업(쓰기 작업) 이 끝나지 않았다면 01번 부터 반복하고, 쓰기가 끝났다면 작업을 종료합니다

![image](https://user-images.githubusercontent.com/109144975/235445117-5ea3644c-22cb-4317-ba0d-ac49895e01d3.png)



프로그램의 입출력 방식에서의 입출력 작업은 CPU가 장치 컨트롤러의 레지스터 값을 읽고 씀으로써 이루어집니다

그런데 CPU는 입출력 장치들의 주소를 어떻게 아는 걸까요 ?
다시 말해, CPU는 장치 컨트롤러의 레지스터를 어떻게 아는 걸까요 ?

CPU 내부에 있는 레지스터와 달리 CPU 의 여러 장치 컨트롤러 속 레지스터를 모두 알고있기는 어렵습니다

아래와 같은 명령어는 어떻게 표현되고, 메모리에 어떻게 저장되어 있을까요 ?

- 프린터 컨트롤러의 상태 레지스터를 읽어라
- 프린터 컨트롤러의 데이터 레지스터에 100을 써라
- 키보드 컨트롤러의 데이터 레지스터를 읽어라
- 하드 디스크 컨트롤러의 데이터 레지스터에 'a'를 써라

여기에는 두가지 방식이 있습니다
- 메모리 맵 입출력
- 고립형 입출력

### 메모리 맵 입출력

메모리 맵 입출력은 메모리에 접근하기 위한 주고 공간과 입출력 장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법입니다

만약 1024 개의 주소를 표현할 수 있는 컴퓨터가 있을 때 1024개 전부 메모리 주소를 표현하는 데 사용하지 않습니다

512개는 메모리 주소를, 512개는 장치 컨트롤러의 레지스터를 표현하기 위해 사용합니다

![image](https://user-images.githubusercontent.com/109144975/235446668-72d7106d-516a-4393-9717-b93796953ff1.png)

주소 공간 일부를 아래와 같이 약속했다고 가정해 봅시다

- 516 번지 : 프린터 컨트롤러의 데이터 레지스터
- 517 번치 : 프린터 컨트롤러의 상태 레지스터
- 518 번지 : 하드 디스크 컨트롤러의 데이터 레지스터
- 519 번지 : 하드 디스크 컨트롤러의 상태 레지스터

그렇다면 CPU는 '517 번지를 읽어 들여라'라는 명령어로 키보드 상태를 읽을 수 있습니다

그리고 '518번지에 a를 써라'라는 명령어로 하드 디스크 컨트롤러의 데이터 레지스터로 데이터를 보낼 수 있습니다

이때 중요한 점은 메모리 맵 입출력 방식에서 CPU는 메모리의 주소들이나 장치 컨트롤러의 레지스터들이나 모두 똑같이 메모리 주소를 대하듯 하면 된다는 것 입니다

메모리에 접근하는 명령어와 입출력 장치에 접근하는 명령어는 굳이 다를 필요가 없습니다

### 고립형 입출력

메모리를 위한 주소 공간과 입출력 장치를 위한 주소 공간을 분리하는 방법입니다

만약 1024개의 주소 공간을 가진 컴퓨터가 있다고 가정해 봅시다

아래 그림처럼 제어 버스에 '메모리 읽기/쓰기' 선 이외에 '입출력 장치 읽기/쓰기'선이 따로 있다면 메모리에도 1024 개의 주소 공간을 활용하고, 입출력 장치도
1024 개의 주소 공간을 활용할 수 있습니다. CPU가 메모리 읽기/쓰기 선이 활성화되는 명령어를 실행할 때는 메모리에 접근하고, 입출력 장치 읽기/쓰기
선이 활성화 되는 명령어를 실행할 때는 장치 컨트롤러에 접근하게 됩니다

![image](https://user-images.githubusercontent.com/109144975/235447783-868314cc-59a9-4bda-a2d0-f0b316a8c8dd.png)

고립형 입출력 방식에는 CPU는 입출력 장치에 접근하기 위해 메모리에 접근하는 명령어와는 다른 (입출력 읽기/쓰기 선을 활성화) 입출력 명령어를 사용합니다

메모리에 접근하는 명령어와 입출력 장치에 접근하는 명령어는 동일했던 메모밀 맵 입출력과는 다른부분을 볼 수 있습니다


![image](https://user-images.githubusercontent.com/109144975/235448386-0a17008f-7bab-4268-8509-54a52733cf12.png)


![image](https://user-images.githubusercontent.com/109144975/235448087-e20a4696-7dc4-4428-bc81-409d16224ba2.png)


## 마무리

- **프로그램 입출력**은 프로그램 속 명령어로 입출력 작업을 하는 방식입니다
- **메모리 맵 입출력**은 메모리에 접근하기 위한 주소 공간과 입출력 잧이에 접근하기 위한 공간을 하나의 주소 공간으로 간주하는 입출력 방식입니다
- **고립형 입출력**은 메모리에 접근하기 위한 주소 공간과 입출력 장치에 접근하기 위한 주소 공간을 별도로 분리하는 입출력 방식입니다