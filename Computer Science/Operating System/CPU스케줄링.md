아래 내용은 [강민철](https://github.com/kangtegong)님의

- [『혼자 공부하는 컴퓨터 구조+운영체제』 책](https://m.hanbit.co.kr/media/books/book_view.html?p_code=B9177037040)
- [『혼자 공부하는 컴퓨터 구조+운영체제』 유튜브](https://www.youtube.com/watch?v=bls_GjX-4U8&list=PLVsNizTWUw7FCS83JhC1vflK8OcLRG0Hl)

를 참고하였습니다.

<br>


# CPU 스케줄링

## CPU 스케줄링 개요

CPU 스케줄링이란 ?
- 모든 프로세스는 CPU를 필요로 하며 서로 먼저 사용하고 싶어함
- 이러한 상황에서 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것이 **CPU 스케줄링**


## 프로세스 우선순위

프로세스마다 **우선순위**가 다르기 때문에 프로세스들이 들어온 순서차례로 돌아가며  CPU를 이용하게 하는 것이 좋은 방법은 아닙니다.

우선순위가 높은 프로세스에는 입출력 작업이 많은 프로세스가 있습니다. 왜 그럴까요 ?

프로세스는 대부분 실행 상태와 대기 상태를 반복하며 실행됩니다. 즉 한번에 모든 프로세스가 실행되어 한 번에 처리되는 것이 아닙니다.

입출력 집중 프로세스는 실행 상태보다 입출력을 위한 대기 상태에 더 많이 머무리게 되며 반대로 CPU 집중 프로세스는 대기 상태보다 실행 상태에 더 많이 머무르게
됩니다.

입출력 장치가 입출력 작업을 완료하기 전까지는 입출력 집중 프로세스는 어차피 대기 상태가 될 예정이기 때문에 입출력 집중 프로세스를 얼른 먼저
처리해버리면 다른 프로세스가 CPU를 사용할 수 있기 때문입니다.

이렇게 모든 프로세스가 CPU를 차례대로 돌아가며 사용하는 것 보다 **우선순위**에 맞게 CPU를 배분하는 것이 더 효율적 입니다.

방금 `우선순위`라는 말을 하였습니다. 이는 프로세스의 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 하기 위해 운영체제는 프로세스 마다
`우선순위`를 부여합니다.

운영체제는 각 프로세스의 PCB에 우선순위를 명시하고, 그 기준으로 먼저 처리할 프로세스를 결정합니다.

## 스케줄링 큐

우선순위에 따라 프로세스를 실행하기 위해 모든 프로세스의 PCB를 다 뒤져가며 순서를 정하는 것은 운영체제 입장에서 비효율적 입니다.

운영체제는 프로세스들에게 '줄을 서서 기다릴 것'을 요구합니다. CPU를 사용하고 싶은 프로세스들, 메모리에 적재되고 싶은 프로세스들, 특정 입출력
장치를 사용하고 싶은 프로세스들을 모두 줄 세우는 것입니다. 그리고 운영체제는 이 줄을 **스케줄링 큐** 로 구현하고 관리합니다.

운영체제가 관리하는 대부분의 자원은 큐로 관리됩니다. 운영체제가 관리하는 줄, 큐 에는 다양한 종류가 있습니다.

대표적으로 준비 큐와 대기 큐가 있습니다. `준비 큐`는 CPU를 이용하고 싶은 프로세스들이 서는 줄을 의미하고, `대기 큐`는 입출력 장치를 이용하기
위해 대기 상태에 접어든 프로세스들이 서는 줄을 의미합니다.

![image](https://user-images.githubusercontent.com/109144975/230416953-016ae5c5-0d14-403a-88e7-4eed738fa5f4.png)

준비 상태에 있는 프로세스들의 PCB는 준비 큐의 마지막에 삽입되어 CPU를 사용할 차례를 기다립니다. 운영체제는 큐에서 프로세스를 하나씩 꺼내어 실행 하되,
그 중 우선순위가 높은 프로세스를 먼저 실행합니다.

프로세스 상태 다이어그램을 아래와 같이 더 세밀하게 완성할 수 있습니다.

![image](https://user-images.githubusercontent.com/109144975/230418409-dc506972-77d8-433a-9746-82351d2dd09e.png)

## 선점형과 비선점형 스케줄링

> 선점형 스케줄링
>
> 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식을 의미
>
> 프로세스가 자원 사용을 독점할 수 없는 스케줄링 방식
>
> 프로세스마다 정해진 시간만큼 CPU를 사용하고, 정해진 시간을 모두 소비하여 타이머 인터럽트가 발생하면 운영체제가 해당 프로세스로 부터 CPU 자원을 빼앗아 다음 프로세스에 할당하는 방식을 의미합니다


> 비 선점형 스케줄링
>
> 프로세스가 자원을 사용중이라면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지 다른 프로세스가 끼어들 수 없는 스케줄링 방식입니다
>
> 프로세스가 자원 독점이 가능한 방식

선점형 스케줄링

장점
- 한 프로세스의 자원 독점을 막을 수 있음
- 프로세스들에게 골고루 자원을 배분할 수 있음

단점
- 프로세스들이 바뀔 때 마다 컨텍스트 스위칭이 일어나여 문맥교환 과정에서 오버헤드가 발생할 수 있음

비 선점형 스케줄링

장점
- 오버헤드가 선점형 스케줄링보다 적음

단점
- 프로세스가 자원을 독점함

## 마무리

- CPU 스케줄링은 공정하고 합리적으로 CPU 자원을 배분하는 방법을 의미
- 프로세스는 우선순위를 가지고 있고, 이는 PCB에 명시됨
- 운영체제는 효율적인 스케줄링을 위해 **스케줄링 큐**를 사용함
- **준비 큐**는 CPU 할당을 기다리는 프로세스들을 위한 큐를 의미
- **대기 큐**는 입출력장치를 기다리는 프로세스들을 위한 큐를 의미
- **선점형 스케줄링**은 프로세스가 이용중인 자원을 뺏을 수 있음
- **비 선점형 스케줄링**은 프로세스가 이용중인 자원을 뺏을 수 없음

# CPU 스케줄링 알고리즘

## 스케줄링 알고리즘의 종류

<U>**FCFS 스케줄링 (First Come First Scheduling)**</U>

> 큐에 삽입된 순서대로 프로세스들을 처리하는 비 선점형 스케줄링 방식

호위 효과
- 오래 사용하는 프로세스가 먼저 도착하면 다른 프로세스는 무작정 기다리는 방식

![image](https://user-images.githubusercontent.com/109144975/230545007-9941a11e-eb9e-4110-9358-649920ebe26c.png)


<U>**최단 작업 우선 스케줄링, SJF(Shortest Job First Scheduling) 스케줄링**</U>
위의 FCFS 스케줄링의 단점인 호위 효과를 방지하기 위해서는 CPU 사용시간이 가장 짧은 프로세스를 먼저 실행시키면 되겠죠 ?

> 비 선점형 알고리즘이며 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 스케줄링 방식

![image](https://user-images.githubusercontent.com/109144975/230545171-b4b4d4b7-529c-4090-8d27-36cff25e833a.png)


<U>**라운드 로빈 스케줄링**</U>

타임 슬라이스
- 각 프로세스가 CPU를 사용할 수 있는 정해진 시간

> 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 **선점형 스케줄링**
>
> 큐에 삽입된 프로세스들은 삽입 된 순서대로 CPU를 사용해되 정해진 시간만큼 CPU를 이용 후 다시 큐의 맨 뒤에 삽입됨
>
> 이때, 문맥 교환이 발생함
>
> 만약 CPU 사용시간이 11ms, 3ms, 7ms 인 프로세스 A, B, C 를 타임 슬라이스가 4ms인 라운드 로빈 스케줄링을 한다면 아래 그림과 같이 수행됩니다


![image](https://user-images.githubusercontent.com/109144975/230546044-f85075f5-d87f-4a94-a2fe-7561129ad71f.png)

- 라운드 로빈 스케줄링에서는 타임 슬라이스 크키가 매우 중요함
- 타임 슬라이스가 너무 크면 FCFS와 다를 바 없이 호위 효과가 생김
- 타임 슬라이스가 너무 작으면 문맥 교환의 비용이 너무 커 CPU가 프로세스 처리보다 프로세스 전환에 더 많은 시간을 쓸 수 있음

<U>**최소 잔여 시간 우선 스케줄링 SRT(Shortest Remaining Time)**</U>

최단 작업 우선 스케줄링 알고리즘 + 라운드 로빈 알고리즘

> 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택 됨

<U>**우선순위 스케줄링**</U>

> 프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 알고르짐

- 앞에서 본 최단 작업 우선 스케줄링, 최소 잔여시간 우선 스케줄링 알고리즘들은 넓은 의미에서 우선순위 스케줄링의 일종으로 볼 수 있음
- 각 스케줄링의 기준에 따라 우선순위를 부여하여 그에 따라 프로세스에게 CPU를 부여하는 방식이기 때문
- 다만 우선순위 스케줄링은 근본적인 문제를 가짐
- 우선순위가 낮은 프로세스는 (준비 큐에 먼저 삽입되었더라도) 우선순위가 높은 프로세스들에 의해 계속해서 연기가 될 수 있음
- 이를 기아(starvation) 이라고 함

**기아** 현상을 방지하기 위해 **에이징(aging)** 이 있음

이는 오래 대기한 프로세스의 우선순위를 점차 높이는 방식
- 예를 들어 1초에 우선순위 1씩 높이는 방법

<U>**다단계 큐 스케줄링**</U>

> 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식
>
> 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리
>
> 우선순위가 가장 높은 큐가 비어 있으면 그 다음 우선순위 큐의 프로세스 처리

![image](https://user-images.githubusercontent.com/109144975/230549032-33d0e931-a956-4f3e-9ea8-865c223e6244.png)


위와 같이 큐를 여러개 두면 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해짐

어떤 큐에는 우선순위가 비교적 높아야 하는 CPU 집중 프로세스가 삽입될 수 있고, 어떤 큐에는 우선순위가 비교적 낮아도 상관 없는 입출력 집중 프로세스
가 삽입될 수 있다

큐 별로 타임 슬라이스를 여러 개 지정하여, 큐 마다 다른 스케줄링 알고리즘을 사용할 수 있다

예를 들어 어떤 큐에서는 타임 슬라이스를 크게, 또 다른 큐에서는 타임 슬라이스를 작게 두어 큐 마다 다른 특징을 갖게하는 것입니다.

추가로 큐와 큐 사이에 스케줄링도 반드시 있어야 하며, 일반적으로 고정 우선순위의 선점형 스케줄링으로 구현된다

예를 들어, 실시간 큐는 대화형 큐보다 절대적으로 높은 우선순위를 가질 수 있다

각 큐는 다음과 같은 우선순위를 갖는다

> 1. 실시간 프로세스
> 2. 시스템 프로세스
> 3. 대화형 프로세스
> 4. 배치 프로세스

각 큐는 낮은 우선순위의 큐보다 절대적인 우선순위를 가진다.

실시간 프로세스, 시스템 프로세스, 대화형 프로세스를 위한 큐들이 모두 비어있지 않으면 배치 큐에 있는 프로세스는 실행될 수 없다.

배치 프로세스가 실행되고 있는데, 대화형 프로세스가 준비 큐에 들어가면 배치 프로세스는 선점될 것이다


<U>**다단계 피드백 큐 스케줄링**</U>

다단계 큐 스케줄링에서는 프로세스들이 큐 사이를 이동할 수 없음

하지만 이런 방식이라면 우선순위가 낮은 프로세스는 게속 연기될 수 있음

기아 현상이 발생 할 수 있음

> 다단계 피드백 큐 스케줄링은 다단계 큐 스케줄링과 비슷함
>
> 차이점은 프로세스들이 큐 사이를 이동할 수 있음
>
> - 새로 준비 상태가 된 프로세스가 있다면 우선순위가 가장 높은 우선순위 큐에 삽입되고 일정 시간(타임 슬라이스) 동안 실행 됨
> - 만약 프로세스가 해당 큐에서 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입됨
> - 결국 CPU를 오래 사용해야 하는 프로세스는 자연스럽게 우선순위가 낮아짐
> - CPU를 비교적 적게 사용하는 입출력 집중 프로세스들은 자연스레 우선순위가 높은 큐에서 실행이 되어 바로 끝남

> 다단계 피드백 큐 스케줄링은 `프로세스들이 큐 사이를 이동`할 수 있는 방식이기 때문에 낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스가 있다면
> 점차 우선순위가 높은 큐로 이동시키는 에이징 기법을 적용하여 기아 현상을 예방할 수 있음
>
> 즉 어떤 프로세스의 CPU 이용 시간이 길면 낮은 우선순위 큐로 이동시키고, 어떤 프로세스가 낮은 우선순위 큐에서 너무 오래 기다린다면 높은 우선순위 큐로 이동시킬 수 있는 알고리즘임


![image](https://user-images.githubusercontent.com/109144975/230552098-310bc31e-f7c3-4164-82d2-642a997d1504.png)

> 다단계 피드백 큐 스케줄링은 구현이 복잡하지만, 가장 일반적인 CPU 스케줄링 알고리즘임


## 마무리

- `선입 선처리 스케줄링` 알고리즘은 준비 큐에 삽입된 순서대로 CPU를 할당합니다
- `최단 작업 우선 스케줄링` 알고리즘은 준비 큐에 삽입된 프로세스들 중 CPU 사용 시간의 길이가 가장 짧은 프로세스부터 CPU를 할당합니다
- `라운드 로빈 스케줄링` 알고리즘은 정해진 시간만큼만 돌아가며 CPU를 할당합니다
- `우선순위 스케줄링` 알고리즘은 가장 높은 우선순위를 가진 프로세스에 CPU를 할당합니다
- `다단계 피드백 큐 스케줄링` 알고리즘은 프로세스들이 큐 사이를 이동할 수 있는 다단계 큐 스케줄링입니다


# CPU 스케줄링 요약

- CPU 스케줄링은 준비 큐에서 대기 플세스를 선택하고 CPU를 할당하는 작업이다. 디스패처에 의해 선택된 프로세스에 CPU가 할당된다
- 스케줄링 알고리즘은 선점적(CPU를 프로세스로부터 뺏을 수 있는 경우) 또는 비 선점적(프로세스가 자발적으로 CPU 제어를 포기해야 하는 경우)일 수 있다
- 스케줄링 알고리즘은 다음 5가지 기준에 따라 평가할 수 있다
    1. CPU 이용률
    2. 처리량
    3. 총 처리 시간
    4. 대기 시간
    5. 응답 시간
- 선입 선처리(FCFS) 스케줄링은 가장 간단한 스케줄링 알고리즘이지만 짧은 프로세스가 매운 긴 프로세스를 기다리게 할 수 있다
- 최단 작업 우선 스케줄링(SJF)은 평균 대기시간이 짧다. 하지만 다음 CPU 버스트의 길이를 예측하기 어려우므로 SJF 스케줄링을 구현하는 것은 어렵다.
- 라운드 로빈(RR) 스케줄링은 CPU 를 타임 슬라이스만큼 프로세스에 할당한다. 프로세스가 시간 할당량이 만료되기 전에 CPU를 포기하지 않으면 프로세스가 선점되고 다른 프로세스가 타임 슬라이스 동안 실행된다
- 우선순위 스케줄링은 각 프로세스에 우선순위를 배정하고 CPU는 우선순위가 가장 높은 프로세스에 할당된다. 우선순위가 동일한 프로세스는 FCFS 순서로 또는 RR 스케줄링을 사용하여 스케줄 할 수 있다
- 다단계 큐 스케줄링은 프로세스를 우선순위에 따라 여러 개의 큐로 분할하고 스케줄러는 우선순위가 가장 높은 큐에서 프로세스를 실행한다. 큐 마다 다른 스케줄링 알고리즘이 사용될 수 있다
- 다단계 피드백 큐는 프로세스가 다른 큐 간에 이주될 수 있는 점을 제외하고 다단계 큐와 유사하다
