# 운영체제

아래 내용은 [강민철](https://github.com/kangtegong)님의 

- [『혼자 공부하는 컴퓨터 구조+운영체제』 책](https://m.hanbit.co.kr/media/books/book_view.html?p_code=B9177037040)
- [『혼자 공부하는 컴퓨터 구조+운영체제』 유튜브](https://www.youtube.com/watch?v=bls_GjX-4U8&list=PLVsNizTWUw7FCS83JhC1vflK8OcLRG0Hl)

를 참고하였습니다.

## 목차

- 운영체제 시작하기
- 프로세스와 스레드 이해하기
- 프로세스와 스레드의 개념
- 멀티프로세스와 멀티스레드의 개념
- CPU 스케줄링 기법 학습하기
- 프로세스와 스레드 관리 학습하기
- 프로세스 동기화
- 교착 상태
- 가상 메모리와 파일 시스템 학습하기
- 가상 메모리 관리
- 파일 시스템


# 운영체제 시작하기

---

## 운영체제란

프로그램(크롬, 게임 등)을 실행하기 위해서는 자원이 필요한데, 이때 필요한 자원을 할당하고, 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램이 운영체제입니다. 

> 운영체제는 여느 프로그램과 마찬가지로 메모리에 적재되어야 합니다.

- 운영체제 프로그램 : 특별한 프로그램으로 일반적인 메모리가 아닌 메모리 내 **커널 영역(kernel space)** 이라는 공간에 따로 적재되어 실행

- 응용 프로그램 : 커널영역을 제외한 나머지 영역, 즉, **사용자 영역** 공간에 적재

예를 들어 3가지의 워드 프로세서, 인터넷 브라우저, 메모장 응용 프로그램을 실행해야한다고 할때

운영체제는 이들의 메모리 주소가 겹치지 않게 2000번지, 1500번지, 1000번지 등으로 적재하여 관리한다.

운영체제를 정부에 비유할 수 있습니다.

정부는 그 나라의 땅, 인력, 돈 등 국내의 자원을 효율적으로 배분하고, 규칙을 만들어 나라 전체를 관리합니다.

운영체제도 마찬가지로 자원인 CPU, 메모리, 하드디스크 등을 응용프로그램에 효율적으로 배분하고, 규칙을 만들어 컴퓨터 시스템 전체를 관리합니다.

## 운영체제를 알아야 하는 이유

개발자 입장에서 운영체제가 없다면 끔찍할 것 입니다. 운영체제가 없다면 아주 간단한 프로그램이라도 하드웨어를 조작하는 코드를 개발자가 모두 직접 
작성해야하기 때문 입니다.

> 운영체제 덕분에 개발자는 하드웨어를 조작하는 코드를 직접 작성할 필요가 없습니다.

운영체제는 알아서 잘 동작할텐데 굳이 알아야 하는 이유는 뭘까요 ?

- 우리가 만든 프로그램은 결국 하드웨어가 실행하고, 그 하드웨어를 조작하는 프로그램이 운영체제입니다.
- 운영체제와의 대화로 하드웨어와 프로그램을 더 깊이 이해하고 **문제 해결**의 실마리를 찾을 수 있기 때문입니다.


## 마무리

- **운영체제**는 실행할 프로그램에 필요한 자원을 할당하고, 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램입니다.
- 운영체제와의 대화를 통해 하드웨어와 프로그램을 더 깊이 이해하고 **문제해결**의 실마리를 찾을 수 있습니다.

<br>

---

<br>

## 운영체제의 심장, 커널

> 커널은 운영체제의 핵심 기능을 담당합니다.

운영체제가 제공하는 서비스 중 커널에 포함되지 않는 서비스
- 사용자 인터페이스 (GUI, CLI)

## 이중모드와 시스템 호출

- 운영체제는 사용자가 실행하는 응용프로그램이 하드웨어 자원에 직접 접근하는 것을 방지하여 자원을 보호합니다.
- 만약 응용프로그램이 자원에 마음대로 접근, 조작한다면 자원관리가 무질서해지고 컴퓨터 전체에 큰 악영향을 끼칠 수 있습니다.
- 운영체제는 응용프로그램들이 자원에 접근시 자신을 통해서만 접근하도록하여 자원을 보호합니다. (일종의 문지기 역할)
- 응용프로그램이 자원 접근시 운영체제에 도움을 요청하는데 이는 '운영체제코드를 실행하려고 한다'와 같이 해석할 수 있습니다.

운영체제의 문지기 역할은 이중 모드로써 구현됩니다.

> 이중모드란 ?
> CPU가 명령어를 실행하는 모드를 사용자모드와 커널모드로 구분하는 방식입니다.
> CPU는 사용자모드로써 실행할 수 있고, 커널 모드로써 실행할 수 있습니다.

**사용자 모드란 ?**
- 운영체제 서비스를 제공받을 수 없는 실행모드
- 일반적인 응용 프로그램은 기본적으로 사용자 모드로 실행
- 이 모드의 프로그램은 CPU는 입출력 명령어와 같이 하드웨어 자원에 접근할 수 없음

**커널 모드란 ?**
- 운영체제 서비스를 제공받을 수 있는 실행모드
- 이 모드로 프로그램을 실행하면 CPU는 자원에 접근하는 명령어를 비롯하여 모든 명령어 실행 가능

사용자 모드로 실행되는 프로그램이 자원에 접근하는 운영체제 서비스를 제공받기 위해서는 운영체제에 요청을 보내 **커널모드**로 전환 되어야 합니다.

이때 운영체제 서비스를 제공받기 위한 요청을 **시스템 호출** 이라고 합니다.

시스템 호출은 **소프트웨어 인터럽트** 입니다.

시스템 호출을 발생시키는 명령어가 실행되면 CPU는 지금까지의 작업을 백업하고, 커널 영역 내에 시스템 호출을 수행하는 코드를 실행한 뒤 기존에 응용 프로그램
으로 복귀합니다.

![image](https://user-images.githubusercontent.com/109144975/223895536-b96559bd-3417-42d4-8ac1-12e4bf590080.png)


**응용프로그램이 하드 디스크에 데이터를 저장하는 과정**

1. 하드디스크에 데이터를 저장하는 시스템 호출을 발생시켜 커널모드로 전환
2. 운영체제 내의 '하드디스크에 데이터를 저장하는 코드'를 실행하여 하드웨어에 접근
3. 다시 사용자 모드로 복귀하여 실행을 이어 나감

![image](https://user-images.githubusercontent.com/109144975/223895782-a1bcea23-5c4b-41a1-8e66-1be12ec7b59a.png)


## 운영체제의 핵심 서비스
- 프로세스 관리
- 자원 접근 및 할당
- 파일 시스템 관리

### _프로세스 관리_

**프로세스** : 실행중인 프로그램, 운영체제(커널)로부터 메모리를 할당받음

하나의 CPU는 한 번에 하나의 프로세스만 실행할 수 있으므로 CPU는 여러 프로세스들을 조금씩 번갈아가며 실행합니다. 이때 각 프로세스는 상태, 사용하고자하는
자원도 다양합니다. (CPU만 사용, 입출려장치를 주로 사용, 등등)

여러 프로세스가 동시에 실행되는 환경에서는 '프로세스 동기화'가 필수적이며 프로세스가 더 이상 실행되지 못하는 상황인 '교착상태'를 해결해야 합니다.

이들은 12장, 13장인 뒷부분에서 다루겠습니다.

### _자원 접근 및 할당_

모든 프로세스는 실행을 위해 자원을 필요로 합니다. 운영체제는 프로세스들이 사용할 자원에 접근하여 필요한 자원을 할당해줍니다.

### CPU

- CPU는 한 번에 하나의 프로세스만 실행할 수 있음
- 운영체제는 프로세스들에 공정하게 CPU를 할당하기 위해 어떤 프로세스부터 얼마나 오래 CPU를 이용하게 할지 결정해야 함
- 이를 CPU 스케줄링이라 함

### 메모리

- 메모리에 적재된 프로세스들은 크기, 주소가 모두 다름
- 동일한 프로세스도 실행할때마다 주소가 달라질 수 있음
- 운영체제는 새로운 프로세스가 적재될 때마다 주소를 결정

### 입출력장치

- 인터럽트 서비스 루틴은 커널영역에 있음
- 입출력장치가 CPU에 하드웨어 인터럽트 요청시 CPU는 하던 일을 백업 후 커널 영역에 있는 인터럽트 서비스 루틴 실행

### _파일 시스템 관리_

- 파일, 디렉터리(폴더) 등을 열고, 생성하고, 삭제하는 **파일 시스템**은 운영체제의 핵심 서비스중 하나


## 마무리

- 커널은 운영체제의 핵심 기능을 담당
- 이중모드는CPU가 명령어를 실행하는 모드를 커널모드와 사용자 모드로 구분하는 방식
- 시스템 호출은 운영체제의 서비스를 제공받기 위해 커널 모드로 전환하는 방법
- 대표적인 운영체제 서비스로 프로세스 관리, 자원 접근 및 할당, 파일 시스템 관리가 있음


<br>

# 프로세스와 스레드

---

## 프로세스 제어 블록

운영체제는 빠르게 번갈아 수행되는 프로세스의 실행 순서를 관리하고, 프로세스에 CPU와 자원을 배분합니다. 이를 위해 프로세스 제어 블록(PCB)을 이용합니다.
수 많은 프로세스들 사이에서 PCB로 특정 프로세스를 식별하고 처리하는데 필요한 정보를 판단합니다.

프로세스 제어 블록 : 프로세스와 관련된 정보를 저장하는 자료구조 (상품에 달린 태그와 비슷), 커널 영역에 생성

PCB는 프로세스 생성 시에 만들어지고 실행이 끝나면 폐기됩니다.

- '새로운 프로세스가 생성되었다' == '운영체제가 새로운 PCB를 생성했다'
- '프로세스가 종료되었다' == '운영체제가 해당 PCB를 폐기했다'

![image](https://user-images.githubusercontent.com/109144975/224181545-c9bf1a5d-0189-4915-ba47-e4227e41dc3e.png)


## PCB에 담기는 정보
- 프로세스 PID
  - 프로세스 구별을 위한 고유 번호
  - 학교와 학번 역할
- 레지스터 값
  - 프로세스를 실행하며 사용했던 프로그램 카운터, 레지스터 값
- 프로세스 상태
  - 프로세스의 상태 (입출력 장치를 기다리는지, CPU를 이용하는 상태인지, CPU를 기다리는 상태인지 등)
- CPU 스케줄링 정보
  - 언제, 어떤 순서로 CPU를 할당 받을지에 대한 정보
- 메모리 관리 정보
  - 프로세스가 어느 주소에 저장되었는지에 대한 정보
  - 베이스 레지스터, 한계 레지스터 값의 정보
  - 페이지 테이블 정보
- 사용한 파일과 입출력 장치 목록
  - 어떤 입출력 장치가 프로세스에 할당되었는지
  - 어떤 파일들을 열었는지에 대한 정보

## 문맥 교환

하나의 프로세스에서 다른 프로세스로 실행 순서가 넘어가면 어떤일이 발생할까요 ?

프로세스 A는 프로그램 카운터를 비롯하여 각 레지스터 값, 메모리 정보, 입출력 장비 등 지금까지의 중간 정보를 백업해야 합니다. 그래야만 다음 차례가
왔을 때 이전까지 실행했던 내용에 이어 다시 재개할 수 있기 때문입니다.

이러한 위의 중간정보들, 즉 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보들을 **문맥(context)**이라고 합니다.

하나의 프로세스 문맥은 해당 프로세스의 PCB에 표현되어 있습니다. PCB에 기록되는 정보들을 모두 문맥이라 볼 수 있습니다.

![image](https://user-images.githubusercontent.com/109144975/224183309-7211643a-f984-4cd7-bd8b-2d0a73db4c57.png)

이처럼 기존 프로세스의 문맥을 PCB에 백업 하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB로 부터 복구하여 새로운 프로세스를 실행하는 것을 문맥교환(context switching)
이라고 합니다.

문맥 교환은 여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리입니다. 프로세스들이 동시에 실행되는 것처럼 보이는 이유는 문맥교환이 그만큼 자주 빨리 
일어나기 때문입니다.

> 문맥 교환을 너무 자주 하면 오버헤드가 발생할 수 있으므로 너무 자주하는 것은 좋지 않습니다.

## 프로세스의 메모리 영역

프로세스가 생성되면 커널 영역에 PCB가 생성됩니다.

> 이때 사용자 영역에서는 크게 **코드 영역, 데이터 영역, 힙 영역, 스택 영역**으로 나뉘어 저장됩니다.
>
> 이 내용은 프로그래밍에서 매우 중요한 내용입니다

![image](https://user-images.githubusercontent.com/109144975/224184963-b14a7d5b-91c4-42a9-abbc-4e5399f3a12a.png)

### 코드영역
- 코드 영역은 텍스트 영역이라고도 부릅니다. 이곳에는 실행할 수 있는 코드, 즉 기계어로 이루어진 명령어가 저장됩니다.
- 코드 영역에는 데이터가 아닌 CPU가 실행할 명령어가 담겨 있기 때문에 쓰기가 금지되어 있습니다.
- 코드 영역은 다시말해 읽기 전용 Read-Only 공간입니다.

### 데이터영역
- **데이터영역**은 잠깐 썼다가 없앨 데이터가 아닌 프로그램이 실행되는 동안 유지할 데이터(**전역변수 global variable** - 프로그램 전체에서 접근할 수 있는 변수 등)가 저장되는 공간입니다.
- 코드영역과 데이터영역은 크기가 변하지 않습니다. 왜냐하면 명령어들은 고정되어있고, 데이터 영역에 저장되는 내용은 실행되는 동안만 유지되기 때문입니다.
- 그래서 '크기가 고정된 영역'이므로 **정적 할당 영역**이라고 부릅니다.
- 반면 힙 영역과 스택 영역은 프로세스 실행 과정에서 크기가 변할 수 있으므로 **동적 할당 영역** 이라고 부릅니다.

## 힙영역
- **힙 영역**은 프로그램을 만드는 사용자, 즉 프로그래머가 직접 할당할 수 있는 저장 공간 입니다.
- 힙 영역 메모리 공간을 할당했다면 이후에 반드시 해동 공간을 반환해야합니다.
- 반환의 의미는 '더 이상 메모리 공간을 사용하지 않겠다'는 의미입니다.
- 반환하지 않는다면 할당된 공간은 계속 메모리가 남기때문에 심각한 메모리 낭비를 초래할 수 있습니다. 이를 메모리 누수라고 합니다.

## 스택영역
- 스택영역은 데이터를 일시적으로 저장하는 공간입니다.
- 데이터 영역에 담기는 값과 달리 순간 잠시 쓰고 없애는 값들이 저장되는 공간입니다.
- 함수의 실행이 끝나면 사라지는 매개 변수, 지역 변수 등이 있습니다.
- 일시적으로 저장할 데이터는 스택 영역에 PUSH 되고, 필요 없는 데이터는 POP 됨으로써 스택 영역이 관리됩니다.
- 힙 영역과 스택 영역은 실시간으로 크기가 변할 수 있으므로 **동적 할당 영역**이라고 부릅니다.
- 힙과 스택이 실시간으로 변하기 때문에 이를 매번 예측할 수 없습니다.
- 따라서 이 둘 사이의 메모리 주소가 겹치지 않도록 하기 위해서 스택 영역은 높은 주소에, 힙 영역은 메모리의 낮은 주소에서 할당이 시작됩니다.

![image](https://user-images.githubusercontent.com/109144975/224187877-6a2bcab7-b321-4ee5-b361-24d51ab24668.png)

## 마무리
- 프로세스는 실행 중인 프로그램입니다. 프로세스의 종류에는 포그라운드, 백그라운드 프로세스가 있습니다.
- 운영체제는 프로세스 제어 블록을 통해 여러 프로세스를 관리합니다.
- 프로세스 간에 실행을 전환하는 것을 문맥 교환이라고 합니다.
- 프로세스 사용자 영역에 크게 코드 영역, 데이터 영역, 스택영역, 힙 영역으로 나뉘어 배치됩니다.

---

## 프로세스 상태

프로세스들이 빠르게 번갈아가며 실행(문맥 교환)될때 프로세스는 여러 상태를 거칩니다.

그리고 운영체제는 프로세스의 상태를 PCB를 통해 인식하고 관리합니다.

이때 가질 수 있는 대표적인 상태는 아래와 같습니다.

### 생성 상태
- 프로세스를 생성 중인 상태를 **생성 상태**라고 합니다.
- 막 메모리에 적재되어 PCB를 할당 받은 상태입니다.
- 생성 상태의 프로세스는 바로 실행되지 않고 준비상태가 되어 CPU할당을 기다립니다.

### 준비 상태
- CPU할당을 기다리는 상태입니다
- 준비상태에서 CPU를 할당받아 실행상태로 전환되는 것을 디스패치(dispatch)라고 합니다.

### 실행 상태
- CPU를 할당 받아 실행 중인 상태입니다.
- 실행 상태 프로세스는 할당된 일정 시간 동안만 CPU를 사용할 수 있습니다.
- 프로세스가 할당된 시간을 모두 사용(타이머 인터럽트가 발생)하면 다시 준비상태가 됩니다.
- 실행 중 입출력장치를 사용할때는 입출력 작업이 끝날때 까지 대기 상태가 됩니다.

### 대기 상태
- 입출력 작업은 CPU에 비해 속도가 느리기에(그 시간에 다른 프로세스에게 CPU를 할당하기 위해), 입출력을 끝낼 때 까지(입출력 완료 인터럽트를 받을 때 까지) 기다려야 합니다.
- 이 입출력장치의 작업을 기다리는 상태를 **대기 상태** 라고 합니다.
- 입출력이 완료되면 다시 준비상태가 됩니다.

### 종료 상태
- 프로세스가 종료된 상태입니다.
- 운영체제가 PCB를 폐기하고 사용한 메모리를 정리합니다.


![image](https://user-images.githubusercontent.com/109144975/224191229-2da4d7b2-baef-4d68-9364-f9bbca757eb2.png)

위 같은 도표를 **프로세스 상태 다이어 그램** 이라고 합니다.

이처럼 컴퓨터 내의 여러 프로세스는 생성, 준비, 실행, 대기, 종료 상태를 거치며 실행됩니다.

운영체제는 이 상태를 PCB에 기록하며 프로세스들을 관리하는 것이지요.

## 프로세스 계층 구조

- 프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있습니다.
- 이때 새 프로세스를 생성한 프로세스를 **부모 프로세스**
- 부모 프로세스에 의해 생성된 프로세스를 **자식 프로세스**라고 합니다.
- 부모 프로세스와 자식 프로세스는 다른 PID를 가집니다
- 많은 운영체제는 이처럼 프로세스가 프로세스를 낳는 계층적인 구조로써 프로세스들을 관리합니다.

프로세스 생성 과정을 도표로 그리면 아래와 같이 트리 구조를 띄게 되는데, 이를 프로세스 계층 구조 라고 합니다.

![image](https://user-images.githubusercontent.com/109144975/224196549-571efc50-d87c-45bd-8001-f76dda5d87cb.png)

예를 들어 사용자가 컴퓨터를 킨 후 로그인 창을 통해 로그인하여 bash 셸로 Vim 이라는 문서 편집기 프로그램을 실행했다고 해봅시다.

이 경우
1. 사용자가 컴퓨터를 켠 순간 최초 프로세스는 로그인 담당 프로세스를 자식 프로세스로 생성하였으며
2. 로그인 프로세스는 bash 셸 프로세스를 자식 프로세스로 생성하였으며
3. bash 셸 프로세스는 Vim 프로세스를 자식 프로세스로 생성한 셈입니다.

## 프로세스 생성 기법

부모 프로세스를 통해 생성된 자식 프로세스들은 **복제와 옷 갈이입기**를 통해 실행됩니다. 다시 말해 부모 프로세스는 **fork**를 통해 복사본을
자식 프로세스로 생성해 내고, 만들어진 복사본(자식 프로세스)은 **exec**를 통해 자신의 메모리 공간을 다른 프로그램으로 교체합니다.

우선 fork, exec 모두 시스템 호출(system call)입니다.

> fork의 경우 자기 자신 프로세스의 복사본을 만드는 시스템 호출입니다.

자식 프로세스는 복사본이므로 부모 프로세스의 자원들(메모리 내용, 열린 파일 목록 등)이 자식 프로세스에 상속됩니다.

(자식 프로세스가 복사본이라 하더라도 엄연히 다른 프로세스이므로 할당된 PID는 서로 다릅니다.)

자식 프로세스는 exec 시스템 호출을 통해 새로운 프로그램으로 전환됩니다.

> exec는 자신의 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 호출입니다.

다시 말해 새로운 프로그램 내용으로 전환하여 실행하는 시스템 호출입니다. exec를 호출하면 코드 영역과 데이터 영역의 내용이 실행할 프로그램의 내용으로
바뀌고, 나머지 영역은 초기화됩니다.

> 프로세스를 다시 정리해보면
> 
> 프로세스란 메모리를 할당 받은 프로그램이 실행중인 것을 의미한다고 하였습니다.
> 
> 그리고 프로세스가 이렇게 생성되면 커널 영역에 PCB가 생성되며 `각각의 프로세스의 사용자 영역에는 코드 영역, 데이터 영역, 힙 영역, 스택영역으로 각각 나뉘어 저장됩니다.`
> 즉 하나의 프로세스에 PCB가 생성된 대로 코드, 데이터, 힙, 스택영역이 할당되는 것입니다.

여기서 fork된 프로세스(자식 프로세스)에 exec를 호출하게 되면 코드 영역과 데이터 영역의 내용이 실행할 프로그램의 내용을 바뀌고, 나머지 영역은 모두 초기화됩니다.

![image](https://user-images.githubusercontent.com/109144975/224407053-452f5848-883e-4e39-aae3-f9e02648e7fc.png)

사용자가 bash 셸에서 ls라는 명령어를 칠 경우

- 셸 프로세스는 fork를 통해 자신과 동일한 프로세스를 생성
- 자식 프로세스(복제 프로세스)는 exec를 통해 ls 명령어를 실행하기 위한 프로세스로 전환되어 실행
- 자식 프로세스의 메모리 공간에는 ls 명령어를 실행하기 위한 내용들이 채워짐

이런 과정들은 즉, 부모가 자식 프로세스를 실행하며 프로세스 계층 구조를 이루는 과정이라 할 수 있습니다.

이들은 fork, exec가 반복되는 과정이기도 합니다.

## 프로세스 만들기_실습

```python
from multiprocessing import Process
import os

def foo():
    print('child process', os.getpid())
    print('my parent is', os.getppid())

if __name__ == '__main__':
    print('parent process', os.getpid())
    child = Process(target=foo).start()
```

![image](https://user-images.githubusercontent.com/109144975/224411295-90703b7a-8782-4c51-9bd4-6a17de888856.png)


line 8은 main이름을 찾은뒤 line 9, 10을 실행하는 코드입니다.

line 9는 현재 부모 PID 값을 출력하는 형태이고 line 10은 foo() 함수를 Process().start()를 통해 자식 프로세스를 생성하고 자식 프로세스의 PID를
출력하고, PPID를 통해 부모의 PID를 출력하는 형태의 코드입니다.

위 사진에서 parent PID가 20192로 동일한 것을 확인할 수 있습니다.


## 각기 다른 작업을 하는 프로세스 생성하기

```python
from multiprocessing import Process
import os

def foo():
    print('This is foo')
    print('foo pid is : ', os.getpid())
def bar():
    print('This is bar')
    print('bar pid is : ', os.getpid())
def baz():
    print('This is baz')
    print('baz pid is : ', os.getpid())

if __name__ == '__main__':
    child1 = Process(target=foo).start()
    child2 = Process(target=bar).start()
    child3 = Process(target=baz).start()
```

![image](https://user-images.githubusercontent.com/109144975/224412585-32c52654-64d9-443e-81e3-b2fbe3b6ccd6.png)

위 프로그램으로 각기 다른 프로세스 3개를 만들고 실행시켜보았습니다.

이를 통해 프로세스를 이해하고 각기 다른 작업을 동시에 수행하는 소스코드도 작성이 가능합니다.

## 마무리
- **프로세스 상태**에는 생성, 준비, 실행, 대기, 종료가 있습니다.
- 프로세스가 다른 프로세스를 생성한 경우 프로세스를 생성한 프로세스를 **부모 프로세스**, 생성된 프로세스를 **자식 프로세스**라고 부릅니다.
- 많은 운영체제는 프로세스가 프로세스를 낳는 **프로세스 계층 구조**로 프로세스들을 관리합니다.

