아래 내용은 [강민철](https://github.com/kangtegong)님의

- [『혼자 공부하는 컴퓨터 구조+운영체제』 책](https://m.hanbit.co.kr/media/books/book_view.html?p_code=B9177037040)
- [『혼자 공부하는 컴퓨터 구조+운영체제』 유튜브](https://www.youtube.com/watch?v=bls_GjX-4U8&list=PLVsNizTWUw7FCS83JhC1vflK8OcLRG0Hl)

를 참고하였습니다.

<br>


# 프로세스 동기화

# 동기화란

## 동기화의 의미

- 동시 다발적으로 실행되는 많은 프로세스는 서로 데이터를 주고받으며 협력하며 실행될 수 있습니다.
- 워드 프로세서에는 사용자로부터 입력받는 프로세스와 입력한 내용의 맞춤법을 검사하는 프로세스, 화면에 출력해주는 프로세스 등이 있습니다.
- 이 프로세스들은 각기 다른 독립적인 프로세스이지만 공동의 목표를 위해 서로 협력하는 존재입니다.

이렇게 협력하는 프로세스들은 아무렇게나 동시에 실행해서는 안됩니다. 올바른 실행을 위해 **동기화**는 필수입니다.

프로세스 동기화는 아래 두가지를 말합니다.

> - 실행 순서 제어 : 프로세스를 올바른 순서대로 실행하기
> - 상호 배제 : 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기

동기화는 특정 자원에 접근할 때 한 개의 프로세스만 접근하게 하거나, 프로세스를 올바른 순서대로 실행하게 하는 것을 의미합니다.

즉 동기화에는 실행 순서 제어를 위한 동기화가 있고 상호 배제를 위한 동기화가 있습니다.

<U>**첫째, 실행 순서 제어를 위한 동기화**</U>

여기 Book.txt 파일이 있으며 이 파일에 대해 Writer 프로세스와 Reader 프로세스가 동시에 실행 중이라고 가정해보겠습니다.

위 두 프로세스는 무작정 아무 순서대로 진행되어서는 안됩니다.

Reader 프로세스는 Writer 프로세스 실행이 끝나야 비로소 실행할 수 있기 때문입니다.

> 컴퓨터가 아닌 종이에 글을 쓴다고 가볍게 생각해보겠습니다.
>
> 연필로 종이에 글을 쓰기도 전에 종이에 적힌 글을 읽을 수 있을까요 ?

즉 Writer 프로세스가 Book.txt 에 값을 저장하기도 전에 Reader 프로세스가 Book.txt 를 읽는 것은 올바른 실행 순서가 아닙니다.
이렇게 동시에 실행되는 프로세스를 올바른 순서대로 실행하는 것이 첫 번째 프로세스 동기화입니다.

<U>**둘째, 상호 배제를 위한 동기화**</U>

`상호 배제`는 공유가 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘입니다.

예시로 계좌 입금에 대해 들어보겠습니다.

현재 저의 계좌에는 10만원이 저축되어 있습니다.

프로세스 A 는 2만원을 계좌에 넣는 프로세스, 프로세스 B 는 5만원을 계좌에 넣는 프로세스라고 가정해보겠습니다.

프로세스 A 의 실행과정은 아래와 같습니다.
- 계좌의 잔액을 읽어 들인다
- 읽어들인 잔액에 2만원을 더한다
- 더한 값을 계좌에 저장한다

프로세스 B 의 실행과정은 아래와 같습니다.
- 계좌의 잔액을 읽어 들인다
- 읽어들인 잔액에 5만원을 더한다
- 더한 값을 계좌에 저장한다

만약 프로세스 A, B가 동시에 실행되었다고 가정해보겠습니다.

당연히 결과는 17만원이 나와야겠지만 막무가내로 실행되었을때는 아래와 같이 그렇지 않을 수 있습니다.

![image](https://user-images.githubusercontent.com/109144975/230562931-70a8d8b3-7963-43b8-a3d9-a79ca674644d.png)

왜 위와 같은 일이 발생하였을까 ?

A와 B 는 잔액 이라는 데이터를 동시에 사용하는데, A가 끝나기도 전에 B가 잔액을 읽어 버렸기 때문에 엉뚱한 결과가 나온 것이다.

A 와 B 를 올바르게 실행하기 위해서는 한 프로세스가 잔액에 접근했을 때 다른 프로세스는 기다려야 합니다.

![image](https://user-images.githubusercontent.com/109144975/230563406-f63269e0-6401-4f30-a3cc-8c3c28bfc326.png)

위와 같이 동시에 접근해서는 안 되는 자원에 동시에 접근하지 못하게 하는것이 **상호 배제를 위한 동기화**입니다.

## 생산과 소비자 문제

- 생산자와 소비자는 동시에 실행되는 스레드가 될 수도 있습니다
- 생산자와 소비자는 `총합` 이라는 데이터를 공유하고 있습니다

```
총합 = 10

생산자() {
  버퍼에 데이터 삽입
  '총합' 변수 1 증가
}
소비자() {
  버퍼에 데이터 빼기
  '총합' 변수 1 감소
}
```

위 상태에서 생산자를 100,000 번, 소비자를 100,000 번 동시에 실행한다면 이상한 값이 나올 것 입니다.

왜냐하면 총합이라는 공유 자원에 대해 생산자, 소비자 프로세스가 제대로 동기화를 하지 않았기 때문입니다.

생산자가 소비자의 작업이 끝나기도 전에 총합을 수정하고, 반대로 소비자도 생산자의 작업이 끝나기 전에 총합을 수정하였기 때문입니다.

즉, 계좌 잔액 문제와 생산자와 소비자의 문제는 동시에 접근해서는 안 되는 자원에 동시에 접근했기 때문에 발생한 문제입니다.

## 공유 자원과 임계 구역

동시에 접근해서는 안되는 자원은 무엇일까요 ?

공유 자원은 전역 변수가 될 수도 있고, 파일, 입출력 장치 등이 될 수 있습니다.

즉 프로세스들이 공동으로 사용하는 자원을 의미합니다.

> 공유 자원 : 공동으로 이용하는 변수, 파일, 장치 등의 자원
>
> 임계 구역 : 공유 자원에 접근하는 코드 중 동시에 실행하면 문제가 발생하는 코드 영역

임계 구역을 다루기 위해 **선점형 커널** 과 **비 선점형 커널** 의 두가지 접근법이 사용된다
- 선점형 커널 : 프로세스가 커널 모드에서 수행되는 동안 선점되는 것을 허용
- 비선점형 커널 : 커널 모드에서 수행되는 프로세스의 선점을 허용하지 않고 커널 모드 프로세스는 커널을 빠져 나갈 때 까지 계속 수행

두 개 이상의 프로세스가 임계 구역에 진입하고자 하면 반드시 둘 중 하나는 대기해야 합니다.

임계 구역에 먼저 진입한 프로세스의 작업이 마무리 된 후 기다렸던 프로세스가 임계 구역에 진입합니다.

> 레이스 컨디션 : 임계구역의 코드를 프로세스들이 동시 다발적으로 실행하여 문제가 발생하는 경우

레이스 컨디션이 발생하면 계좌 잔액 문제나 생산자와 소비자 문제처럼 데이터의 일관성이 깨지는 문제가 발생합니다.

운영체제는 이러한 임계 구역 문제를 아래 세 가지 원칙하에 해결해야 합니다.
- 상호 배제 : 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없다
- 진행 : 임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다
- 유한 대기 : 한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 언젠가 임계 구역에 들어올 수 있어야 한다

## 마무리

- `동기화`는 특정 자원에 접근할 때 한 개의 프로세스만 접근하거나 프로세스를 올바른 순서대로 실행하게 하는 것을 의미함
- `공유자원`은 공동으로 사용하는 자원으로, 전역 변수가 될 수도 있고, 파일이 될 수도 있고, 입출력 장치, 보조 기억장치가 될 수 있음
- `임계 구역`은 공유 자원에 접근하는 코드 중 동시에 실행하면 문제가 발생하는 코드 영역을 의미함, 임계 구역에 진입한 프로세스가 있다면 다른 프로세스는 임계 구역 밖에서 기다려야 함
- `상호배제`는 한 프로세스가 임계 구역에서 작업 중이면 다른 프로세스가 임계 구역에 들어갈 수 없도록 제어하는 것

# 동기화 기법

동기화를 위한 대표적인 도구
- 뮤텍스 락
- 세마포
- 모니터
  를 학습해보겠습니다


## 뮤텍스 락

뮤텍스 락을 탈의실에 비유해보겠습니다

사람들이 일렬로 줄을 서서 탈의실에 들어간다고 가정하면 한 사람만이 탈의실에 들어갈 수 있습니다.

그러고 탈의실에서 사람이 나오면 다음 사람이 탈의실에 들어갈 수 있습니다.

사람들이 한 명씩만 탈의실로 들어갈 수 있으니, 사람을 '프로세스' 탈의실을 '임계구역'이라고 할 수 있습니다.

밖에서는 탈의실에 사람이 있는지 없는지에 대한 유무를 자물쇠가 걸려 있는지 아닌지로도 판단할 수 있겠죠
만약 자물쇠가 걸려있지 않다면 탈의실을 이용하면 됩니다.

이 자물쇠의 기능 즉 임계구역 내에 프로세스가 있는지를 구현한 것이 `뮤텍스 락`입니다.

뮤텍스 락은 동시에 접근해서는 안되는 자원에 동시에 접근하지 않도록 만드는 도구, 다시 말해 상호 배제를 위한 동기화 도구 입니다.

뮤텍스 락을 하나의 전역 변수, 두개의 함수로 단순한 형태로도 구현이 가능합니다.
- 자물쇠 역할 : 프로세스들이 공유하는 전역 변수 lock
- 임계 구역을 잠그는 역할 : acquire 함수
- 임계 구역의 잠금을 해제하는 역할 : release 함수

**acquire 함수**
- 프로세스가 임계 구역에 진입하기 전에 호출하는 함수
- 만약 임계구역이 잠겨있다면 임계 구역이 열릴 때 까지 임계 구역을 반복적으로 확인
- 임계 구역이 열려있다면 임계 구역을 잠그는(lock 을 true로 바꾸는) 함수 입니다

**release 함수**
- 임계 구역에서 작업이 끝나고 호출하는 함수
- 현재 잠긴 임계 구역을 열어주는 (lock을 false로 바꾸는) 함수


```
acquire() { 
  while (lock == true) /* 만약 임계구역이 잠겨있다면*/ 
  ;       /*임계구역이 잠겨있는지를 반복적으로 확인*/
  lock = true; /*만약 임계 구역이 잠겨있지 않다면 임계 구역 잠금*/
}

release() {
    lock = false; /* 임계 구역 작업이 끝났으니 잠금 해제*/
}
```


```java
acquire(); // 자물쇠 잠겨있는지 확인, 잠겨 있지 않다면 잠그고 들어가기
//임계구역  // 임계 구역에서의 작업 진행
release(); // 자물쇠 반환
```

이렇게 되면 프로세스는
- 락을 획득할 수 없다면 무작정 기다리고,
- 락을 획득할 수 있다면 임계 구역을 잠근 뒤 임계 구역에서의 작접을 진행하고,
- 임계 구역에서 빠져나올 때엔 다시 임계 구역의 잠금을 해제함으로써
  임계 구역을 보호할 수 있습니다.

acquire 에서 while 문을 통해 임계구역이 잠겨있는지 유무를 지속적으로 확인해보는데 이런 대기 방식을 **바쁜대기** 라고 합니다.

## 세마포

만약 탈의실이 여러개의 상황처럼 공유 자원이 여러 개 있을 경우 여러 개의 프로세스가 각각 공유 자원에 접근이 가능해야 합니다.

이와 같이 공유 자원(탈의실)이 여러개라면 각 공유자원에 프로세스가 접근이 가능해야 합니다.

`세마포`도 뮤텍스 락과 비슷하게 하나의 변수와 두 개의 함수로 단순하게 구현할 수 있습니다.

- 임계 구역에 진입할 수 있는 프로세스의 개수(사용 가능한 공유 자원의 개수)를 나타내는 `전역 변수 S`
- 임계 구역에 들어가도 좋은지, 기다려야 할지를 알려주는 `wait 함수`
- 임계 구역 앞에서 기다리는 프로세스에 '이제 갈 수 있다'고 신호를 주는 `signal 함수`

세마포도 임계 구역 진입 전 후 로 wait(), signal() 을 호출합니다.

```python
wait()
#  임계 구역
signal()
```

wait 함수
```java
wait() {
    while(S <= 0)  // 1
        ; // 2
    S--; // 3
}
```

1. 만일 임계 구역에 진입할 수 있는 프로세스의 개수가 0 이하라면
2. 사용할 수 있는지 반복적으로 확인
3. 임계 구역에 진입할 수 있는 프로세스 개수가 하나 이상이면 S 를 1 감소시키고 임계 구역에 진입한다


signal 함수
```java
signal() {
    S++; // 1
}
```

1. 임계 구역에서의 작업을 마친 뒤 S를 1 증가시킨다.

만약 세개의 프로세스 P1, P2, P3 가 두 개의 공유 자원에서 1, 2, 3 순서로 접근한다면 공유자원이 2개가 있으니 변수 S는 2가 됨

> 1. 프로세스 P1 wait 호출. S는 현재 2이므로 S를 1 감소 시키고 임게구역 진입
> 2. 프로세스 P2 wait 호출. S는 현재 1이므로 S를 1 감소 시키고 임게구역 진입
> 3. 프로세스 P3 wait 호출. S는 현재 0이므로 무한히 반복하며 S 확인
> 4. 프로세스 P1 임계구역 작업 종료, signal 호출. S를 1 증가
> 5. 프로세스 P3 S가 1이 됨을 확인. S는 현재 1이므로 S를 1 감소 시키고 임계 구역 진입


위 상황에서 한가지 문제가 있습니다.

3번에서 만약 S가 0일 경우 P3이 무한정 반복하여 S의 상태를 확인한다는 점입니다. 이는 바쁜 대기를 반복하여 확인할 시간에 CPU는 더 생산성 있는
작업을 할 수 있을 텐데, 낭비하는 점에서 손해입니다.

실제로 세마포는 더 좋은 방법을 사용합니다.

- wait 함수는 만일 사용할 수 있는 자원이 없을 경우(S=0) 해당 프로세스 상태를 대기 상태로 만들고
- 그 프로세스의 PCB를 세마포를 위한 대기 큐에 넣습니다
- 다른 프로세스가 임계 구역 작업 완료 후 signal 함수를 호출하면
- signal 함수는 대기 중인 프로세스를 대기 큐에서 제거하고 프로세스 상태를 준비상태로 변경 후 준비 큐에 옮겨줍니다

wait코드

```java
wait() {
    S--;
    if (S < 0) {
        add this process to Queue; // 1
        sleep(); // 2
    }
}
```

1. 해당 프로세스 PCB를 대기 큐에 삽입한다
2. 대기 상태로 접어든다


```java
signal() {
    S++;
    if (S <= 0) {
        remove a process p from Queue; // 1
        wakeup(p); // 2
    }
}
```

1. 대기 큐에 있는 프로세스 p를 제거한다
2. 프로세스 p를 대기 상태에서 준비 상태로 만든다

이를 예시로 공유자원은 2개, 접근하려는 프로세스는 3개라고 가정해보겠습니다. 공유자원이 2개 이므로 S는 2 입니다.

> 1. P1 wait 호출. S를 1 감소시키면 S는 1이므로 임계 구역 진입
> 2. P2 wait 호출. S를 1 감소시키면 S는 0이므로 임계 구역 진입
> 3. P3 wait 호출. S를 1 감소시키면 S는 -1 이므로 본인의 PCB를 대기 큐에 넣고 대기 상태로 전환
> 4. P1 임계 구역 작업 종료, signal 호출. S를 1 증가 하면 0이므로 대기 상태였던 P3를 대기큐에서 준비 큐로 옮김
> 5. 깨어난 P3 wait 호출, 임계구역 진입
> 6. P2 임계구역 작업 종료, signal 호출. S 1 증가하면 1
> 7. P3 임계구역 작업 종료, signal 호출. S 1 증가하면 2


동기화에 대해서
- 상호 배제를 위한 동기화
- 실행 순서 제어를 위한 동기화
  와 같이 2가지 기법이 있다고 하였습니다

위 설명의 내용들은 세마포를 이용한 상호 배제를 위한 동기화 기법이었다면

이번에는 실행 순서를 제어하는 기법을 알아보겠습니다.

방법은 세마포의 변수 S를 0으로 두고 먼저 실행할 프로세스 뒤에 signal 함수, 다음에 실행할 프로세스 앞에 wait 함수를 붙이면 됩니다

- P1이 먼저 실행되면 P1이 임계 구역에 먼저 진입하는 것은 당연한 일이고
- P2가 먼저 실행된다 하더라도 wait 함수를 만나므로 P1이 임계구역에 먼저 진입하게 됩니다.
- 이후 P1이 signal 함수를 호출하면 그제서야 P2가 임계구역으로 진입합니다.
- P2가 wait 함수를 호출하게 되면 무조건 대기 큐로 이동하기 때문에 누가 먼저 실행되는지와 관계 없이 P1, P2 순서로 진행됩니다.

## 모니터

세마포는 그 자체로 훌륭한 프로세스 동기화 도구 이지만, 사용하기는 불편한 면이 있습니다.

만약 잘못된 코드로 인해 아래와 같은 상황이 발생할 수 있습니다

**세마포의 잘못된 사용 예시**

> 세마포를 누락한 경우, wait와 signal 순서를 헷갈린 경우, wait와 signal을 중복해서 사용한 경우

`모니터`는 세마포에 비해 사용자가 사용하기에 편리한 도구 입니다. 모니터는 공유 자원과 공유 자원에 접근하기 위한 인터페이스(통로)를 묶어 관리합니다.

그리고 프로세스는 반드시 인터페이스를 통해서만 공유 자원에 접근하도록 합니다.

![image](https://user-images.githubusercontent.com/109144975/230591570-53ea60dc-a5fd-4d35-ab13-8b8f533a9de6.png)

- 모니터를 통해 접근하고자 하는 프로세스를 큐에 삽입하고
- 큐에 삽입된 순서대로 하나씩 공유자원을 이용하도록 합니다
- 즉, 모니터는 인터페이스에 접근하기 위한 큐(모니터에 진입하기 위한 큐)를 만들고
- 모니터 안에는 결국 무조건 하나의 프로세스만 들어오도록 하여 상호 배제를 제공합니다

![image](https://user-images.githubusercontent.com/109144975/230592328-a13fb400-f6da-45b6-a29a-32133e2ecdc6.png)


모니터는 세마포와 마찬가지로 실행 순서 제어를 위한 동기화 기법을 제공합니다
- 특정 조건으로 프로세스를 실행, 일시 중단하기 위해 모니터는 **조건변수**를 사용합니다

조건 변수로 wait, signal 연산을 수행할 수 있습니다

- wait의 경우 호출한 프로세스의 상태를 대기 상태로 전환하고 일시적으로 조건 변수의 대기 큐에 삽입하는 연산입니다
- signal의 경우 wait를 호출하여 큐에 삽입된 프로세스의 실행을 재개하는 연산입니다
    - 모니터 안의 프로세스는 항상 하나만 실행되어야 하므로 하나의 프로세스가 끝난 뒤 signal 호출을 통해 대기 큐에 있는 프로세스를 모니터로 불러들이는 역할을 합니다.

여기서 헷갈리는 부분이 있을 수 있습니다

wait는 총 2가지 상황에서 쓰입니다

1. 모니터에 진입하기 위해 삽입되는 큐 (상호 배제를 위한 큐)
    - 모니터에 한 번에 `하나의 프로세스만 진입`하도록 하기 위해 만들어진 큐
2. wait가 호출되어 실행이 중단된 프로세스들이 삽입되는 큐 (조건 변수에 대한 큐)
    - 모니터에 이미 진입한 프로세스의 실행 조건이 만족될 때까지 `잠시 실행이 중단되어 기다리기 위해` 만들어진 큐

![image](https://user-images.githubusercontent.com/109144975/230595354-8d66cf56-8c79-46ec-97bd-414f5df42886.png)


위 상황에서 어떤 프로세스가 x.wait() 을 통해 조건 변수 x에 대한 wait를 호출했다고 가정한다면 다음 그림처럼 x 에 대한 큐에 삽입 되므로
`모니터는 다시 비게 됩니다.` `모니터가 빈 상황`이므로 다른 프로세스가 모니터 안에 들어올 수 있습니다.

![image](https://user-images.githubusercontent.com/109144975/230595240-720e19df-9621-41de-8542-1bacd3476397.png)


wait 연산으로 일시 중지된 프로세스는 다른 프로세스의 signal 연산을 통해 실행이 재개될 수 있습니다
- 즉, signal 은 wait 를 호출하여 큐에 삽입된 프로세스(위 상황에서는 조건변수 x에 대한 큐에 있는 프로세스)의 실행을 재개하는 연산입니다.

어떤 프로세스가 위 상황에서 x.signal 을 통해 조건 변수 x 에 대한 signal을 호출한다면, 이를 통해 조건 변수 x에 대해 대기 상태였던 프로세스가 깨어나 모니터 안으로 다시 들어올 수 있게 됩니다.

![image](https://user-images.githubusercontent.com/109144975/230595781-2d800934-0175-42b3-b87c-a455e98bdf34.png)

모니터 안에는 반드시 하나의 프로세스만 있을 수 있습니다.
- **wait**를 호출했던 프로세스는 **signal**을 호출한 프로세스가 `모니터를 떠난 뒤`에 실행됩니다
- 혹은 **signal**을 호출한 프로세스의 실행을 **일시 중단**하고 `자신이 실행된 뒤` 다시 **signal**을 호출하여 프로세스의 수행을 재개합니다
- 중요한 점은 모니터는 조건 변수를 이용하여 아래와 같이 실행 순서 제어를 위한 동기화를 제공합니다

> - 특정 프로세스가 아직 실행될 조건이 되지 않았을 때에는 wait를 통해 실행을 중단한다
> - 특정 프로세스가 실행될 조건이 충족되었을 때에는 signal을 통해 실행을 재개한다

## 마무리

- `뮤텍스 락`은 임계 구역을 잠금으로써 프로세스 간의 상호 배제를 이룹니다
- `세마포`는 공유 자원이 여러개 있는 임계 구역 문제도 해결할 수 있는 동기화 도구 입니다
- `모니터`는 세마포에 비해 사용자가 사용하기 편리한 동기화 도구로 조건 변수를 사용합니다


## 동기화 요약

- 경쟁 조건은 프로세스가 공유 데이터에 병행하게 접근할 때 발생하며 최종 결과는 병행 접근이 발생한 특정 순서에 따라 다르다. 경쟁 조건으로 인해 공유 데이터 값이 손상될 수 있다
- 임계구역은 공유 데이터가 조작될 수 있으며, 경쟁 조건이 발생할 수 있는 코드 영역이다. 임계구역 문제는 데이터를 협력적으로 공유하기 위해 자신의 활동을 항상 동기화 하도록 설계하는 것이다
- 임계구역 문제에 대한 해결책은
    1. 상호 배제 : 한 번에 하나의 프로세스만 임계구역에서 활성화 된다
    2. 진행 : 임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다
    3. 유한 대기 : 한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 언젠가 임계 구역에 들어올 수 있어야 한다 (무한정 대기하면 안됨)
- 의 세가지 요구사항을 충족해야 한다
- 뮤텍스 락은 프로세스가 임계 구역에 들어가기 전에 락을 획득하고 임계구역에서 나올 때 락을 해제하여 상호 배제를 제공한다
- 세마포를 사용하면 락의 사용 여부를 나타내는 값을 이진수가 아닌 정수로 얻어 다양한 동기화 해결이 가능하다
- 모니터는 프로세스 동기화의 추상 데이터 유형이다
    - 모니터는 프로세스가 특정 조건이 true가 될 때 까지 대기할 수 있게 하고 조건이 true가 되면 서로에게 신호를 보낼 수 있게 허용하는 조건 변수를 사용한다
- 임계구역 문제에 대한 해결책은 교착 상태를 포함한 라이브니스 문제를 겪을 수 있다