# 관계형데이터모델링

아래 학습은

- [생활코딩님의 강의](https://www.youtube.com/watch?v=1d38YZKCM88&list=PLuHgQVnccGMDF6rHsY9qMuJMd295Yk4sa&index=1)
- [gillog님의 DB](https://velog.io/@gillog/DB-11-1N-NM-%EA%B4%80%EA%B3%84)

를 참고하였습니다.

---

**MODEL 이란 ?**

어떤 목적을 가지고 진짜를 모방한 것

> 좋은 모델 : 목적에 부합하는 모방


**학습 순서**

1. 업무파악
2. 개념적 데이터 모델링
3. 논리적 데이터 모델링
4. 물리적 데이터 모델링

> 데이터 모델링이란 ?
>
> 문제를 현실로부터 뜯어내서 고도의 추상화 과정을 거쳐 그것을 컴퓨터라는 새로운 현실로 옮겨 담는 작업
>
> 두 세계는 다르기 때문에 처음에 해결하려고 했던 문제가 데이터베이스 표에 잘 담겼는 지를 확인하는 작업을 끊임없이 계속해서 해나가야 함 

## 업무파악

**기획**
- 우리가 만들고자 하는 것들을 UI를 함께 만들어나가며 소통하는 것. (말의 기능을 불신하자. 말이란 매우 추상적이므로)

![](https://user-images.githubusercontent.com/109144975/218390095-6e9eff99-f253-41b8-8916-f68d3d530e6e.png)

![](https://user-images.githubusercontent.com/109144975/218390141-fb801da4-829f-4ea7-b004-7546e076b2de.png)

![](https://user-images.githubusercontent.com/109144975/218390176-b9917b86-48c2-46b9-97bb-834bde64c095.png)

<br>

<br>

## 개념적 모델링

<br>

### 개념적 모델링이란 ?

우리가 파악한 업무에서 개념을 뽑아내는 과정

1. 필터
2. 언어

Entity Relationship Diagram

![](https://user-images.githubusercontent.com/109144975/218391181-16105bc0-fe59-419e-aba0-66a8cfc94c6b.png)

> ERD 는 현실을 3개의 관점으로 바라볼 수 있는 finder을 제공해 준다.
> 
> 1. 정보 : 정보를 발견하고 다른사람에게 표현할 수 있게 도와준다.
> 2. 그룹 : 서로 연관된 정보들을 그룹핑해서 인식하고 이것을 다른사람들에게 표현할 수 있게 해준다.
> 3. 관계 : 정보, 그룹 사이의 관계를 인식하고 그것을 다른 사람에게 표현할 수 있게 해준다.


<br>

### 관계형 데이터베이스 다운개념의 구조

- 우리가 만들고자 하는것에는 여러가지 정보가 흩어져 있다.
- 서로 연관된 정보들을 묶어주는 큰 덩어리들을 가져와야 한다.
- 이들을 표현하는데에는 설명이 가능하고, 모순이 없다면 모든 방법이 가능하다.
- 하지만 이들을 각각의 동등한 객체로 바라봐야 한다. (아래 이유 설명)
  - 이유는 관계형 데이터 모델링을 하고 있으므로 그에 잘 어울리는 개념이 더 유리

서로 연관된 정보들을 내포된 관계가 아닌 동등한 객체로 바라봐야 하는 이유

- RDB는 내포관계를 허용하지 않음 (내포관계는 RDB에 어울리지 않는다는 시그널)
- 거대 단일 테이블로 표현을 하면 중복이 발생함
- 주제에 따라서 데이터를 그룹핑 할 수 있음
- `JOIN` 사용에 따른 이점 : `SELECT 댓글, 내용, 댓글.작성일, 저자.이름, 저자.소개 FROM 댓글 LEFT JOIN 저자 ON 댓글.저자 아이디 = 저자.아이디`

<br>

### 테이블과 컬럼 생성

테이블 : Entity - table

컬럼 : Attribute - column

Entity들 간의 상호 관계

![](https://user-images.githubusercontent.com/109144975/218396479-279fa8a4-308c-4f3d-a6e8-f6b4b580db0b.png)

<br>

**개념적 데이터 모델링**

개념에 집중, 데이터베이스의 패러다임으로부터 거리를 둠

![](https://user-images.githubusercontent.com/109144975/218397199-45fb764e-55d4-42a7-9f5e-03d7e292d6d2.png)

<br>

### 엔티티, 속성 정의, 식별자 지정, 엔티티간의 연결

<br>

**엔티티 정의**

> TIP : 모든 정보가 있는 화면이 아닌 각각의 쓰기 화면을 보면 표로 만들기에 적합한 엔티티가 대체로 드러남  

![](https://user-images.githubusercontent.com/109144975/218398125-013f7842-407c-41a3-8308-c7875ab60b2d.png)

<br>

**속성 정의**

![](https://user-images.githubusercontent.com/109144975/218400137-8610e2fc-9b6f-4f96-a295-e10fafe651cb.png)

<br>

**식별자 지정**

식별자 : 그 대상을 제외한 누구도 같은 값을 가지면 안됨 (주민등록번호)

> - 기본키 (primary key) : 식별자로 지정된 키
> 
> - 후보키 (candidate key) : 식별자가 될 수 있는 후보 키
> 
> - 대체키 (alternate key) : 후보키 중 기본키를 제외한 나머지 키

![](https://user-images.githubusercontent.com/109144975/218401545-da4d84e3-f935-4b44-a719-233dc6129230.png)

중복키 (composite key) : 두가지를 합쳐서 식별해야하는 키

![](https://user-images.githubusercontent.com/109144975/218402057-b2c8ee1b-03e2-42b0-b02c-c3573f3e1cb5.png)

<br>

**엔티티간의 연결**

![](https://user-images.githubusercontent.com/109144975/218408152-991bb305-3961-462d-893a-7a61280af1de.png)

글의 저자 아이디 컬럼은 `외래키` 이다.

외래키 (FK)
- 외래에 있는 테이블과 연결할때 사용하는 열쇠
- 관계형 데이터베이스의 relationship은 Primary Key 와 Foreign Key가 연결되는 것을 통해서 실제로 구현 됨

![](https://user-images.githubusercontent.com/109144975/218409184-661de4df-0a47-42be-8715-907157802b63.png)

<br>

### Cardinality

<br>

**1 : 1**

![](https://user-images.githubusercontent.com/109144975/218477644-44205410-0741-4bc7-9506-7ab08eefcc25.png)

<br>

**1 : N**

![](https://user-images.githubusercontent.com/109144975/218477720-50037755-dff2-4a0a-b8d9-55151d8de30e.png)

<br>

**N : M**

![](https://user-images.githubusercontent.com/109144975/218477532-5f3970cf-45e4-43ce-8d49-a4c0371a3987.png)


<br>

### Optionality

- 저자에게 댓글은 Optional 이다. `ERD 상 표현 : O`
- 댓글에게 저자는 Mandatory 이다. `ERD 상 표현 : |`
- 저자는 댓글을 작성하지 않을수도 있다.
- 각 댓글은 반드시 저자가 있다.

![](https://user-images.githubusercontent.com/109144975/218479967-d914ce21-1da7-4563-b793-90ca09b815a8.png)



<br>

### ERD 완성

<br>

![](https://user-images.githubusercontent.com/109144975/218543387-5c284255-49a8-4725-9eef-b8548d494057.png)


이 [링크](https://drive.google.com/file/d/1u6GA1vTP8tmq9BhXXWgtdXe8jqPdLHuC/view?usp=sharing)에서 확인이 가능합니다.

### Entity Relationship Diagram Helper

[http://erd.yah.ac/](http://erd.yah.ac/)

위 링크는 생활코딩님이 만드신 ERD 작성시 관계에 대한 부분을 도와주는 도구 입니다.


## 논리적 데이터 모델링

- 개념적 데이터 모델리에서 뽑아낸 개념을 관계형 데이터 베이스 패러다임에 어울리게 데이터 형식을 잘 정리정돈 하는 것

- 이 과정에서 구체적인 제품 특성이나 성능과 같은것은 크게 신경쓰지 않음

- 관계형 데이터 베이스 패러다임에 어울리는 가장 이상적인 모습으로 개념을 정리하는 것이 포인트

Mapping Rule

![](https://user-images.githubusercontent.com/109144975/218490914-593825e6-a9ba-4a61-a484-8ae3fd1e2010.png)

### 테이블과 컬럼 생성

> 속성의 제약조건을 설정하는 것 : 그 컬럼에 대한 도메인(영역)을 설정한다

### 1 : 1 관계의 처리

- `PK(Primary Key)` : 엔티티를 식별할 수 있는 대표키, 테이블에서 중복되지 않는 (Unique) 값, Null 일 수 없음.

- `FK(Foreign Key)` : 다른 테이블의 기본키를 참조, 모든 필드는 참조하는 기본키와 동일한 도메인 (값의 종류, 범위)을 갖는다.
모든 필드 값은 참조하는 기본키와 동일하거나 null 일 수 있다.

`1 : 1 관계`란 어느 엔티티 쪽에서 상대 엔티티와 반드시 하나의 관계를 가지는 것을 의미한다.

그렇다면 1 : 1 관계에서는 `누가 FK`를 가져가야 할까 ?

(1 : N 관계에서는 헷갈리지 않음 왜냐하면 1에 PK, N 쪽에 FK를 주면 되므로)

각 테이블의 의존성을 따져보자

![](https://user-images.githubusercontent.com/109144975/218545950-553adbcf-9f57-4155-a671-1277376d4807.png)

위의 예시에서는 저자는 휴면저자의 존재 유무에 관계없이 레코드생성이 가능하다.

반면에 휴면저자는 저자 없이 레코드 생성이 불가하다.

즉, 휴면저자는 저자에게 의존하고 있다.

혼자서도 잘 지내는 테이블은 부모테이블, 부모에게 의존하는 테이블은 자식 테이블이라고 생각하면 편하다.

그런 맥락에서 저자 테이블(부모 테이블)에 PK(기본키)를 두고 휴면저자 테이블(자식 테이블)에 FK(외래키)를 두면 대체로 해결된다. 

![](https://user-images.githubusercontent.com/109144975/218547054-b9dec229-5b38-48a7-b856-b34f1f746f14.png)


### 1 : N 관계의 처리

`1 : N 관계`란 한 쪽 엔티티가 관계를 맺은 엔티티 쪽의 여러 객체를 가질 수 있는 것을 의미한다.

예를 들어 글은 여러 댓글 들을 가질 수 있다.

반대로 댓글은 반드시 하나의 글을 가져야만 한다.

이러한 관계를 `1 : N 관계`라고 하며, 계층적인 구조로 이해할 수 도 있다.

그렇다면 1 : N 관계에서는 `누가 FK`를 가져야 할까 ?

여러 댓글(N)의 입장에서 하나의 글(1)중 어떤 글에 속해 있는지 표현해야 하므로 **글 테이블의** `PK`**를 댓글 테이블에** `FK`**로 집어 넣어 
관계를 표현**한다. 

즉, 글 테이블(1)에서는 글의 댓글이 누구인지에 대한 정보를 넣을 필요가 겂고, 댓글 테이블(N)에서만 각각의 댓글이 자신의 글 정보(FK)를 넣음
으로써 관계를 표현할 수 있다.

![](https://user-images.githubusercontent.com/109144975/218560786-27cdffdb-a562-4d7f-b3e2-6d2b06306df4.png)


### N : M 관계의 처리

`N : M 관계`는 관계를 가진 양쪽 엔티티 모두에서 `1 : N 관계`를 가지는 것을 말한다.

즉, 서로가 서로를 `1 : N 관계`로 보고 있는 것이다.

예를 들어, 저자와 글의 관계를 생각해보자, 한 명의 저자는 여러 글에 참여할 수 있다고 가정해본다면 `1 : N 관계`를 가진다.

반대로, 하나의 글에 여러명의 저자가 참여할 수 있다고 한다면 `1 : N 관계`를 가진다.

그러므로 저자와 글은 `N : M 관계`를 가진다고 할 수 있다.

`N : M 관계`는 서로가 서로를 `1 : N 관계`, `1 : M 관계`로 갖고 있기 때문에, 서로의 `PK`를 자신의 `FK`으로 갖고 있으면 된다.

하지만 일반적으로 `N : M 관계`는 두 테이블의 대표키를 컬럼으로 갖는 또 다른 테이블(아래 그림에서 author_topic 테이블)을 생성해서 관리한다.

![](https://user-images.githubusercontent.com/109144975/218562561-2d3ede6f-57ed-46da-8a7e-176196ead4b6.png)
