# 관계형데이터모델링

아래 학습은

- [생활코딩님의 강의](https://www.youtube.com/watch?v=1d38YZKCM88&list=PLuHgQVnccGMDF6rHsY9qMuJMd295Yk4sa&index=1)
- [gillog님의 DB](https://velog.io/@gillog/DB-11-1N-NM-%EA%B4%80%EA%B3%84)
- [망나니 개발자님의 정규화](https://mangkyu.tistory.com/110)

를 참고하였습니다.

---

**MODEL 이란 ?**

어떤 목적을 가지고 진짜를 모방한 것

> 좋은 모델 : 목적에 부합하는 모방


**학습 순서**

1. 업무파악
2. 개념적 데이터 모델링
3. 논리적 데이터 모델링
4. 물리적 데이터 모델링

<br>

데이터 모델링이란 ?

- 문제를 현실로부터 뜯어내서 고도의 추상화 과정을 거쳐 그것을 컴퓨터라는 새로운 현실로 옮겨 담는 작업
- 두 세계는 다르기 때문에 처음에 해결하려고 했던 문제가 데이터베이스 표에 잘 담겼는 지를 확인하는 작업을 끊임없이 계속해서 해나가야 함 

<br>

> **3 가지 모델링**
> 
> - 개념적 모델링 : Entity를 추출하고 개체와 개체들 간의 관계에서 ER다이어그램을 만드는 과정
> 
> - 논리적 모델링 : 개념적 모델링에서 만든 ER 다이어그램을 사용하려는 DBMS에 맞게 사상(Mapping)하여 실제 데이터베이스로 구현하기 위한 관계 스키마
> 모델을 만드는 과정
>   - 논리적 모델링 과정에는 상세속성 추철, 정규화 수행, 데이터 표준화 수행 등이 있음
> - 물리적 모델링 : 논리적 모델을 실제 컴퓨터의 저장 장치에 저장하기 위한 물리적 구조를 정의하고 구현하는 과정



<br>



## 업무파악

**기획**
- 우리가 만들고자 하는 것들을 UI를 함께 만들어나가며 소통하는 것. (말의 기능을 불신하자. 말이란 매우 추상적이므로)

![](https://user-images.githubusercontent.com/109144975/218390095-6e9eff99-f253-41b8-8916-f68d3d530e6e.png)

![](https://user-images.githubusercontent.com/109144975/218390141-fb801da4-829f-4ea7-b004-7546e076b2de.png)

![](https://user-images.githubusercontent.com/109144975/218390176-b9917b86-48c2-46b9-97bb-834bde64c095.png)

<br>

<br>

## 개념적 모델링

<br>

### 개념적 모델링이란 ?

정보 모델링(Information Modeling)이라고도 불리는 개념적 모델링(Conceptual Modeling)이란 요구사항을 수집하고 분석한 결과를 토대로 업무의
핵심적인 개념을 구분하고 전체적인 뼈대를 만드는 과정입니다.

즉 개념적 모델링이란 개체(Entity)를 추출하고 개체들 간의 관계를 정의하여 ER 다이어 그램을 만드는 과정까지를 말합니다. 

Entity Relationship Diagram

![](https://user-images.githubusercontent.com/109144975/218391181-16105bc0-fe59-419e-aba0-66a8cfc94c6b.png)

> ERD 는 현실을 3개의 관점으로 바라볼 수 있는 finder을 제공해 준다.
> 
> 1. 정보 : 정보를 발견하고 다른사람에게 표현할 수 있게 도와준다.
> 2. 그룹 : 서로 연관된 정보들을 그룹핑해서 인식하고 이것을 다른사람들에게 표현할 수 있게 해준다.
> 3. 관계 : 정보, 그룹 사이의 관계를 인식하고 그것을 다른 사람에게 표현할 수 있게 해준다.


<br>

### 관계형 데이터베이스 다운개념의 구조

- 우리가 만들고자 하는것에는 여러가지 정보가 흩어져 있다.
- 서로 연관된 정보들을 묶어주는 큰 덩어리들을 가져와야 한다.
- 이들을 표현하는데에는 설명이 가능하고, 모순이 없다면 모든 방법이 가능하다.
- 하지만 이들을 각각의 동등한 객체로 바라봐야 한다. (아래 이유 설명)
  - 이유는 관계형 데이터 모델링을 하고 있으므로 그에 잘 어울리는 개념이 더 유리

서로 연관된 정보들을 내포된 관계가 아닌 동등한 객체로 바라봐야 하는 이유

- RDB는 내포관계를 허용하지 않음 (내포관계는 RDB에 어울리지 않는다는 시그널)
- 거대 단일 테이블로 표현을 하면 중복이 발생함
- 주제에 따라서 데이터를 그룹핑 할 수 있음
- `JOIN` 사용에 따른 이점 : `SELECT 댓글, 내용, 댓글.작성일, 저자.이름, 저자.소개 FROM 댓글 LEFT JOIN 저자 ON 댓글.저자 아이디 = 저자.아이디`

<br>

### 테이블과 컬럼 생성

테이블 : Entity - table

컬럼 : Attribute - column

Entity들 간의 상호 관계

![](https://user-images.githubusercontent.com/109144975/218396479-279fa8a4-308c-4f3d-a6e8-f6b4b580db0b.png)

<br>

**개념적 데이터 모델링**

개념에 집중, 데이터베이스의 패러다임으로부터 거리를 둠

![](https://user-images.githubusercontent.com/109144975/218397199-45fb764e-55d4-42a7-9f5e-03d7e292d6d2.png)

<br>

### 엔티티, 속성 정의, 식별자 지정, 엔티티간의 연결

<br>

**개체와 개체타입**

개체(Entity) : 사람, 사물, 장소, 개념 과 같이 유,무형의 정보를 가지고 있는 독립적인 실체

- 데이터베이스에서 개체란 데이터를 가진 대상이다.
- 데이터들이 가진 공통의 속성이 개체타입(Entity Type)이며 이 개체의 집합을 개체 집합(Entity Set)이라 한다.
- `게임` 이라는 개체 타입에 개체들은 '스타크래프트', '피파온라인', '배틀그라운드'가 된다.


**엔티티 정의**

아래는 저자, 글, 댓글의 개체타입(Entity) 에 대한 설명이다.

![](https://user-images.githubusercontent.com/109144975/218398125-013f7842-407c-41a3-8308-c7875ab60b2d.png)

> TIP : 모든 정보가 있는 화면이 아닌 각각의 쓰기 화면을 보면 표로 만들기에 적합한 엔티티가 대체로 드러남


<br>

**속성**

- 속성은 개체가 가진 성질을 의미한다.
- 속성은 기본적으로 타원으로 표현하며 개체 타입을 나타내는 직사각형과 실선으로 연결된다.
- 속성이 개체를 유일하게 식별할 수 있는 키(Primary Key : PK)일 경우 속성 이름에 밑줄을 귿는다. (아래 그림은 수정이 필요함)

**속성 정의**

![](https://user-images.githubusercontent.com/109144975/218400137-8610e2fc-9b6f-4f96-a295-e10fafe651cb.png)

<br>

**식별자 지정**

식별자 : 그 대상을 제외한 누구도 같은 값을 가지면 안됨 (주민등록번호)

> - 기본키 (primary key) : 식별자로 지정된 키
> 
> - 후보키 (candidate key) : 식별자가 될 수 있는 후보 키
> 
> - 대체키 (alternate key) : 후보키 중 기본키를 제외한 나머지 키

![](https://user-images.githubusercontent.com/109144975/218401545-da4d84e3-f935-4b44-a719-233dc6129230.png)

중복키 (composite key) : 두가지를 합쳐서 식별해야하는 키

![](https://user-images.githubusercontent.com/109144975/218402057-b2c8ee1b-03e2-42b0-b02c-c3573f3e1cb5.png)

<br>

**엔티티간의 연결**

![](https://user-images.githubusercontent.com/109144975/218408152-991bb305-3961-462d-893a-7a61280af1de.png)

글의 저자 아이디 컬럼은 `외래키` 이다.

외래키 (FK)
- 외래에 있는 테이블과 연결할때 사용하는 열쇠
- 관계형 데이터베이스의 relationship은 Primary Key 와 Foreign Key가 연결되는 것을 통해서 실제로 구현 됨

![](https://user-images.githubusercontent.com/109144975/218409184-661de4df-0a47-42be-8715-907157802b63.png)

<br>

### Cardinality

<br>

**1 : 1**

![](https://user-images.githubusercontent.com/109144975/218477644-44205410-0741-4bc7-9506-7ab08eefcc25.png)

<br>

**1 : N**

![](https://user-images.githubusercontent.com/109144975/218477720-50037755-dff2-4a0a-b8d9-55151d8de30e.png)

<br>

**N : M**

![](https://user-images.githubusercontent.com/109144975/218477532-5f3970cf-45e4-43ce-8d49-a4c0371a3987.png)


<br>

### Optionality

- 저자에게 댓글은 Optional 이다. `ERD 상 표현 : O`
- 댓글에게 저자는 Mandatory 이다. `ERD 상 표현 : |`
- 저자는 댓글을 작성하지 않을수도 있다.
- 각 댓글은 반드시 저자가 있다.

![](https://user-images.githubusercontent.com/109144975/218479967-d914ce21-1da7-4563-b793-90ca09b815a8.png)



<br>

### ERD 완성

<br>

![](https://user-images.githubusercontent.com/109144975/218543387-5c284255-49a8-4725-9eef-b8548d494057.png)


이 [링크](https://drive.google.com/file/d/1u6GA1vTP8tmq9BhXXWgtdXe8jqPdLHuC/view?usp=sharing)에서 확인이 가능합니다.

### Entity Relationship Diagram Helper

[http://erd.yah.ac/](http://erd.yah.ac/)

위 링크는 생활코딩님이 만드신 ERD 작성시 관계에 대한 부분을 도와주는 도구 입니다.


## 논리적 데이터 모델링

- 개념적 데이터 모델리에서 뽑아낸 개념을 관계형 데이터 베이스 패러다임에 어울리게 데이터 형식을 잘 정리정돈 하는 것

- 이 과정에서 구체적인 제품 특성이나 성능과 같은것은 크게 신경쓰지 않음

- 관계형 데이터 베이스 패러다임에 어울리는 가장 이상적인 모습으로 개념을 정리하는 것이 포인트

Mapping Rule

![](https://user-images.githubusercontent.com/109144975/218490914-593825e6-a9ba-4a61-a484-8ae3fd1e2010.png)

### 테이블과 컬럼 생성

> 속성의 제약조건을 설정하는 것 : 그 컬럼에 대한 도메인(영역)을 설정한다

### 1 : 1 관계의 처리

- `PK(Primary Key)` : 엔티티를 식별할 수 있는 대표키, 테이블에서 중복되지 않는 (Unique) 값, Null 일 수 없음.

- `FK(Foreign Key)` : 다른 테이블의 기본키를 참조, 모든 필드는 참조하는 기본키와 동일한 도메인 (값의 종류, 범위)을 갖는다.
모든 필드 값은 참조하는 기본키와 동일하거나 null 일 수 있다.

`1 : 1 관계`란 어느 엔티티 쪽에서 상대 엔티티와 반드시 하나의 관계를 가지는 것을 의미한다.

그렇다면 1 : 1 관계에서는 `누가 FK`를 가져가야 할까 ?

(1 : N 관계에서는 헷갈리지 않음 왜냐하면 1에 PK, N 쪽에 FK를 주면 되므로)

각 테이블의 의존성을 따져보자

![](https://user-images.githubusercontent.com/109144975/218545950-553adbcf-9f57-4155-a671-1277376d4807.png)

위의 예시에서는 저자는 휴면저자의 존재 유무에 관계없이 레코드생성이 가능하다.

반면에 휴면저자는 저자 없이 레코드 생성이 불가하다.

즉, 휴면저자는 저자에게 의존하고 있다.

혼자서도 잘 지내는 테이블은 부모테이블, 부모에게 의존하는 테이블은 자식 테이블이라고 생각하면 편하다.

그런 맥락에서 저자 테이블(부모 테이블)에 PK(기본키)를 두고 휴면저자 테이블(자식 테이블)에 FK(외래키)를 두면 대체로 해결된다. 

![](https://user-images.githubusercontent.com/109144975/218547054-b9dec229-5b38-48a7-b856-b34f1f746f14.png)


### 1 : N 관계의 처리

`1 : N 관계`란 한 쪽 엔티티가 관계를 맺은 엔티티 쪽의 여러 객체를 가질 수 있는 것을 의미한다.

예를 들어 글은 여러 댓글 들을 가질 수 있다.

반대로 댓글은 반드시 하나의 글을 가져야만 한다.

이러한 관계를 `1 : N 관계`라고 하며, 계층적인 구조로 이해할 수 도 있다.

그렇다면 1 : N 관계에서는 `누가 FK`를 가져야 할까 ?

여러 댓글(N)의 입장에서 하나의 글(1)중 어떤 글에 속해 있는지 표현해야 하므로 **글 테이블의** `PK`**를 댓글 테이블에** `FK`**로 집어 넣어 
관계를 표현**한다. 

즉, 글 테이블(1)에서는 글의 댓글이 누구인지에 대한 정보를 넣을 필요가 겂고, 댓글 테이블(N)에서만 각각의 댓글이 자신의 글 정보(FK)를 넣음
으로써 관계를 표현할 수 있다.

![](https://user-images.githubusercontent.com/109144975/218560786-27cdffdb-a562-4d7f-b3e2-6d2b06306df4.png)


### N : M 관계의 처리

`N : M 관계`는 관계를 가진 양쪽 엔티티 모두에서 `1 : N 관계`를 가지는 것을 말한다.

즉, 서로가 서로를 `1 : N 관계`로 보고 있는 것이다.

예를 들어, 저자와 글의 관계를 생각해보자, 한 명의 저자는 여러 글에 참여할 수 있다고 가정해본다면 `1 : N 관계`를 가진다.

반대로, 하나의 글에 여러명의 저자가 참여할 수 있다고 한다면 `1 : N 관계`를 가진다.

그러므로 저자와 글은 `N : M 관계`를 가진다고 할 수 있다.

`N : M 관계`는 서로가 서로를 `1 : N 관계`, `1 : M 관계`로 갖고 있기 때문에, 서로의 `PK`를 자신의 `FK`으로 갖고 있으면 된다.

하지만 일반적으로 `N : M 관계`는 두 테이블의 대표키를 컬럼으로 갖는 또 다른 테이블(아래 그림에서 author_topic 테이블)을 생성해서 관리한다.

![](https://user-images.githubusercontent.com/109144975/218562561-2d3ede6f-57ed-46da-8a7e-176196ead4b6.png)


<br>


### 정규화 소개 (Normalization)

정규화란 ?

- 정규화(Normalization)의 기본 목표는 `테이블 간의 중복된 데이터를 허용하지 않는다`는 것

- 중복된 데이터를 허욜하지 않음으로써 `무결성(Integrity)를 유지`할 수 있으며, DB의 저장 용량 역시 줄일 수 있음

<br>


### 제 1 정규화

제 1 정규화란 ?

테이블의 컬럼이 원자값(Atomic Value, 하나의 값)을 갖도록 테이블을 분해하는 것이다.

예를 들어 아래와 같은 고객 취미 테이블이 존재한다고 가정하자.

![image](https://user-images.githubusercontent.com/109144975/218652017-58c76360-42ba-495b-a901-5b4daa5e2fe9.png)

위의 테이블에서 추신수와 박세리는 여러 개의 취미를 가지고 있으므로 제 1 정규형을 만족하지 못하고 있다.

이를 제 1 정규화를 진행한 테이블은 아래와 같다.

![image](https://user-images.githubusercontent.com/109144975/218652050-e5cf5cb9-beb4-4015-9189-391715156763.png)

<br>

**(조금 더 복잡한 예시)**

만약 아래와 같은 표가 있다고 가정해보자.

![image](https://user-images.githubusercontent.com/109144975/218654485-4571848e-3bea-42ee-8332-918d6cf1a66e.png)


<br>

위 표에서는 tag 컬럼의 rdb, free, commertcial이 각각 중복되는 현상이 발생하였다.

이는 관계형 DB에서 바람직하지 않은 형태이다.

만약 아래와 같은 SQL문을 사용하고자 할때 동작하지 않기 때문이다.

```sql
SELECT * FROM topic WHERE tag = 'rdb';
SELECT * FROM topic ORDER BY tag;
```

따라서 하나의 컬럼에는 하나의 값이 존재하도록 변경해야 한다.

이를 하기 위해서는 테이블을 나누는 방법이 있다.

먼저 topic 테이블의 상황을 살펴보자.

topic 테이블에서는 title, type을 사용하여 중복키를 사용하고 있으며 하나의 topic에는 여러개의 tag가 있을 수 있고, 하나의 tag에서도 여러개의 topic이 있을 수 있다.

따라서 topic과 tag의 관계(Cardinality)는 `N : M 관계` 이다.

이는 `1 : N , N : 1 관계`로 Mapping Table(연결 테이블)을 사용하여 풀어낼 수 있다.

기존의 tag 컬럼을 없애고 새로운 tag테이블을 만들어 필드에 값들을 넣고 인덱스를 만들어 준다.

그리고 tag는 topic의 title에만 의존하고 있다. type이 paper(종이책)인지 online 인지와는 관계없이 어떤 title인지와 관계가 있다.

topic_tag_relation 테이블 (Mapping Table) 에서는 topic의 title을 가져와 topic_title을 컬럼으로 사용하고 tag테이블의 id를 가져와 tag_id로 사용한다.

![image](https://user-images.githubusercontent.com/109144975/218658300-7f4c30a1-7b49-4e44-8f58-56134ed54cc3.png)

### 제 2 정규화

제 2 정규화란 제 1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해하는 것이다.

완전 함수 종속이라는 것은 기본키의 부분집합이 결정자가 되어선 안된다는 것을 의미한다.

즉 **부분적인 종속을 제거**하는 것이 핵심이다.

아래 예시를 사진으로 먼저 이해해보자.

![image](https://user-images.githubusercontent.com/109144975/218662466-bd495018-7c43-4290-b567-5e426c5a2dba.png)


제 1 정규화를 진행한 테이블들을 이전 제 1 정규화 하였던 그림에서 살펴보면 description, created, author_id, ... 등이 중복되는 것을 볼 수 있다.

이는 관계형 데이터베이스에서 바람직하지 않은 형태이다.

이를 해결하기 위한 방법은 부분적으로 종속되는 컬럼들만 모으고 전체적으로 종속되고 있는 컬럼들을 또 따로 나누는 것이다.

아래는 제 2 정규형의 핵심인 부분 종속성을 제거한 표이다.

![image](https://user-images.githubusercontent.com/109144975/218661920-e2947422-30d3-4f3b-8093-2d0fdddb80ed.png)


### 제 3 정규화

제 3 정규화란 릴레이션 R이 제 2 정규형을 만족하고 기본키가 아닌 속성이 기본키에 비이행적(Non-Transitive)으로 종속할 때(직접 종속)를 의미합니다.

여기서 이행적 종속이란, A -> B, B -> C가 성립할 때 A -> C가 성립되는 함수 종속성을 의미합니다.

아래와 같이 게절학기 릴레이션 관계에서 학생 번호 501의 강좌이름이 데이터베이스 -> 스포츠 경영학으로 변경된다면 수강료도 15000원이 되어야 합니다.

하지만 아래 테이블에서는 강좌이름과 수강료 사이의 관계가 없으므로 이름을 변경한다고 하여 수강료에 변경이 생기지는 않습니다.

그러므로 아래의 속성들을 독립적으로 만드는 것이 아니라 학생 번호로 학생이 수강하는 강좌의 이름을 찾게하고 그 학생 번호가 참조하는 강좌 이름을 참조하여
수강료를 찾게하여 결국에는 학생번호가 수강료를 참조할 수 있게 만들면 이 관계가 제 3 정규형이 됩니다.

![image](https://user-images.githubusercontent.com/109144975/218663638-c99143fa-5419-4478-8199-9c7c0e3c5648.png)


만약 컬럼의 이름들 중 prefix가 동일하다면 그 컬럼들은 독립시킬 가능성이 높다는 의미

(위의 제 2 정규화 topic 테이블 사진과 비교해보자.) 

![image](https://user-images.githubusercontent.com/109144975/218701783-6e2e613e-5214-49ef-8333-986f13c0ecbc.png)


## 물리적 데이터 모델링


index : 인덱스는 행에 대한 읽기 성능을 향상시킴, 하지만 쓰기 성능을 저하 시킴

### 역정규화 소개

- 쓰기의 편리함을 위해 읽기의 성능을 희생하는 것
- 정규화를 통해 분리되었던 관계에서 중복을 허용하고 다시 통합하거나 분할하여 구조를 재조정하는 과정
  - 정규화된 관계는 하나의 관계들을 최소 단위로 분리하는 작업이기 때문에 원하는 자료가 하나의 관계에 존재하지 않아 `JOIN`을 해서 참조해야 하는 상황이 많다.
  - 이는 데이터베이스에 저장된 자료를 검색하는 시간을 증가시키며 성능을 저하시킬 수 있다.
- 따라서 데이터베이스의 물리적 설계 과정에서 성능을 향상시키기 위해 역정규화를 실행한다.

릴레이션 역정규화
- 릴레이션 병합 : 두 릴레이션 간의 잦은 참조로 성능이 저하딜 경우 이 문제점을 해결하기 위해 병합한다.
- 릴레이션 분할
  - 수직분할 : 자주 사용하는 속성과 그렇지 않은 속성을 구분해서 분할
  - 수평분할 : 자주 사용하는 튜플과 그렇지 않는 튜플을 구분해서 분할

속성 역정규화
- 릴레이션의 성능을 향상시키기 위해 속성 또는 파생속성을 추가한다.
  - 파생 속성 : 현재 릴레이션에는 없는 속성이지만 작업의 효율을 위해 현 속성으로부터 계산이나 가공에 의해 파생되는 속성.