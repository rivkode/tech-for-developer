# 자료구조

본 내용은

- 유용재 교수님의 [자료구조 2주차](https://www.youtube.com/watch?v=-kjd6PPeihw&t=5841s)

을 정리한 내용입니다.


![image](https://user-images.githubusercontent.com/109144975/223969359-84f08b11-c378-4278-9159-55c15136699d.png)


![image](https://user-images.githubusercontent.com/109144975/223964710-581e9e0b-ebe0-4a89-9207-307163c8811e.png)


## 시간 복잡도 뜻

시간 복잡도란 ?
- 어떤 프로그램이 소요하는 시간을 나타내는 개념
- Q 컴파일 시간과 실행 시간 중, 프로그램 차원에서 더 중히 고려해야 할 것은 ?
  - 실행 시간
  - 실행시간은 데이터 수에 영향을 받기 때문

시간복잡도 TC = 컴파일 시간 C + 실행시간 T(n)

### Program Step
- 실행 시간과 객체의 속성이 서로 독립일 때 프로그램 단위로 시간복잡도와 직결됨
- 1줄 실행, 즉 한 발짝 나간다
- 실행시간을 한눈에 알아볼 수 있도록 추상적인 개념(연산 등을 고려하지 않음)

### Exercise

아래 HELLO가 출력되는 총 횟수를 n에 대해 나타내면 ?

```python
count = 0

for i in range(0, n-5):
    for j in range(0, 10):
        for k in range(0, 100):
            count = count + 1
            print("HELLO")
```

f(n) = 1000n - 5000

BigO 로 나타낸다면 ?
f(n) = O(n)

![image](https://user-images.githubusercontent.com/109144975/223962564-fbc99721-09db-4f72-af83-42094e7ac561.png)

결국 핵심은 **시간복잡도의 간략화**

![image](https://user-images.githubusercontent.com/109144975/223964391-8164f41a-7b0a-4ed8-b1ba-807283e748f1.png)

끓는 물을 예시로 생각해본다면 물은 100도 이상에서는 무조건 끓기때문에 300도, 400도, 500도가 되어도 끓게 되어있다.

위 식에서의 `f(n) = 1000n - 5000` 이며 n*을 1로 놓고 c를 1000으로 둔다면

> 모든 n >= 1 에 대하여
> 
> 1000n - 5000 <= 1000n이 성립
> 
> 한다
> 
> 즉, g(n) = n, f(n) = O(n)

<br>

### 직관적인 Big - O 해석을 위해 아래 **4가지 규칙**들을 기억하자

> - **가장 중요한 항** 이외에는 시간 복잡도에서 무시된다
>   - f(n) = 1000n + 5000 -> 5000은 영향이 없으므로 f(n) = O(1000n)
> - **상수 하나 곱한다고** 시간 복잡도에 영향을 미칠 수 없다
>   - O(1000n) -> O(n)으로 표기되어야 함
> - 일단 최대한 단순화해놓고, **비교하기 편한 것 부터보자**
>   - f(n) = 5n^2 + 2n + 10 -> O(n^2)
> - n* 하나만 찾으면 되니, n이 한없이 커질 때를 생각하자
>   - 2^n과 n^2 중 시간 복잡도가 높은 쪽은 ?
>   - 커지는 비율을 생각하자, n 과 n+1을 서로 비교하자
>   - 2^n의 경우 차이는 2배
>     - (2^(n+1)/2^n) = 2 이므로
>   - n^2의 경우 차이는 0.0000...01 배
>     - ((n+1)^2 / n^2) = 0.000000..01 이므로
>     - 2가 더 크다. 따라서 2^n의 시간복잡도가 더 높다