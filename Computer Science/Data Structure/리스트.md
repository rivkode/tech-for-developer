# 리스트

---

작업의미

insert(i, x) - x를 리스트 i번 원소로 삽입한다. (맨 앞자리는 0번)

append(x) - 원소 x를 리스트의 맨 뒤에 추가한다.

pop(i) - 리스트의 i번 원소를 삭제하면서 알려준다.

remove(x) - 리스트에서 (처음으로 나타나는) x를 삭제한다.

index(x) - 원소 x가 리스트의 몇 번 원소인지 알려준다.

clear() - 리스트를 깨끗이 청소한다.

count(x) - 리스트에서 원소 x가 몇 번 나타나는지 알려준다.

reverse() - 리스트의 순서를 역으로 뒤집는다.

sort() - 리스트의 원소들을 정렬한다.



## 파이썬 내장 리스트의 한계

파이썬 리스트는 배열로 구현되어 있다. 하부가 배열로 구성되어 있는 한 피할 수 없는 비효율이 있다.

- 삽입, 삭제


리스트에서 원소 삽입 시에 삽입하는 오른쪽부터 끝까지 모든 원소를 한 칸씩 시프트해주는 부담이 있다.

[1, 2, 3, 4, 5, 6, 7]

-> insert(3,77)

[1, 2, 3, 77, >>4, >>5, >>6, >>7]

<br>


- 꽉찬 공간에서 삽입, 반대 경우

배열의 크기가 5라고 가정

[1, 2, 3, 4, 5]

-> insert(3, 77)

[1, 2, 3, 77, 4, 5, , , , ]

꽉 찬 상태에서 삽입이 시도될 때 새 배열에 원소들을 모두 복사하는 예다.이럴 때는 기존보다 2배 큰 크기의 새 배열을 할당받아 기존 배열의 내용을 배열로 복사하고 리스트가 새
배열과 매핑되도록 한다.


# 연결 리스트

---

연결 리스트는 배열의 공간 낭비를 피할 수 있는 자료구조다. 원ㅅ가 추가될 때마다 공간을 할당받아 추가하는 동적할당 방식을 따르기 때문이다.

__head는 첫번째 노드에 대한 레퍼런스이며 원소의 총 수를 저장하는 __numItems 필드가 있다.

> 노드란 ?
>
>노드는 item필드와 다음 노드를 가리키는 next 필드로 구성된다. item필드는 정수나 실수같이 복잡한 객체가 될 수 있다.
next 필드는 다음 노드를 가리키는 링크(C언어의 포인터역할)다.


작업의미는 리스트와 동일

### 원소 삽입

insert(i, newItem)

- x = 삽입할 원소
- prev.next = 이전 노드가 가리키는 다음 노드

```python
newNode.item = x
newNode.next = prev.next
prev.next = newNode
__numItems += 1 // 이 부분을 처음 시작하지 않는 이유는 ?
```

새 노드를 정의하고 prev.next 레퍼런스를 새 노드와 링크시킨후 prev.next를 newNode와 링크시켜 삽입을 만들어 낸다.

더미헤드노드가 있을 경우 삽입하고자 하는 노드 앞에 항상 직전 노드가 존재해 두가지의 경우로 나누지 않아도 되는 장점이 있다.

>더미헤드 노드를 사용하는 장단점은 ?
>
> - 더미노드가 있으면 이중 연결리스트에서 head와 tail이 움직일 필요가 없어진다.
> - 삽입/삭제 시 코드가 간결해지고 논리가 쉬워진다


### 원소 삭제

remove(self, x)

- prev.next = 이전 노드가 가리키는 다음 원소
- next - 다음


```python
prev.next = prev.next.next
--numItems -= 1
```

prev.next가 삭제 노드 다음 노드로 건너뛰어 링크하도록 만든다.

### 기타 작업들

원소 반환

get(i)

```python
curr = __head
for index in range(i+1):
    curr = curr.next
return curr
```

isEmpty()

```python
isEmpty():
    return __numItems == 0
```

size()

```python
size():
    return __numItems
```

clear()

```python
clear():
    newNode.next = None
    __head = newNode
    __numItems = 0
```

### 배열리스트와 연결리스트의 비교

<br>

배열리스트
- 고정된 크기, 정적
- 연속된 공간(i번째 원소를 찾을때 상수시간)
- 공간이 초과할 경우 2배의 크기로 재할당

배열리스트
- 들어오는 대로 공간 할당, 동적
- 연속되지 않은 공간(i번째 원소를 찾을때 n의 시간)
- 다음 원소의 링크를 위한 공간 필요


## 연결리스트의 개선 및 확장

- 원형 연결 리스트

연결 리스트에 있는 마지막 노드의 링크가 None값을 가지는 구조에서는 첫 노드와 마지막 노드에 대한 접근성이 극적으로 차이가 난다.

변수 __tail을 두면 맨 앞과 맨 뒤에서 원소 삽입/삭제 시 모두 상수시간이 든다. 단방향 연결 리스트에서는 마지막 노드를 노드 링크가 None인지로
판별했는데, 원형 연결 리스트에서는 링크가 더미 헤드 노드를 가리키는지로 판별한다.
즉 __tail 변수를 통해 얻을 수 있는 이점은 접근성의 차이가 맨 앞과 뒤에서 차이가 없어진 것이다. 따라서 extend(), copy(), reverse() 의 시간부담이
매우 적어졌다.

- 양방향 연결 리스트

양방향 연결 리스트는 각 노드가 앞뒤 양방향으로 링크된다.

각 노드가 직전 노드에 대한 링크도 가져 한 노드만 알면 앞뒤로 자유롭게 이동이 가능하다.