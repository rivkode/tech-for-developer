# 리스트

---

작업의미

insert(i, x) - x를 리스트 i번 원소로 삽입한다. (맨 앞자리는 0번)

append(x) - 원소 x를 리스트의 맨 뒤에 추가한다.

pop(i) - 리스트의 i번 원소를 삭제하면서 알려준다.

remove(x) - 리스트에서 (처음으로 나타나는) x를 삭제한다.

index(x) - 원소 x가 리스트의 몇 번 원소인지 알려준다.

clear() - 리스트를 깨끗이 청소한다.

count(x) - 리스트에서 원소 x가 몇 번 나타나는지 알려준다.

reverse() - 리스트의 순서를 역으로 뒤집는다.

sort() - 리스트의 원소들을 정렬한다.



## 파이썬 내장 리스트의 한계

파이썬 리스트는 배열로 구현되어 있다. 하부가 배열로 구성되어 있는 한 피할 수 없는 비효율이 있다.

- 삽입, 삭제


리스트에서 원소 삽입 시에 삽입하는 오른쪽부터 끝까지 모든 원소를 한 칸씩 시프트해주는 부담이 있다.

[1, 2, 3, 4, 5, 6, 7]

-> insert(3,77)

[1, 2, 3, 77, >>4, >>5, >>6, >>7]

<br>


- 꽉찬 공간에서 삽입, 반대 경우

배열의 크기가 5라고 가정

[1, 2, 3, 4, 5]

-> insert(3, 77)

[1, 2, 3, 77, 4, 5, , , , ]

꽉 찬 상태에서 삽입이 시도될 때 새 배열에 원소들을 모두 복사하는 예다.이럴 때는 기존보다 2배 큰 크기의 새 배열을 할당받아 기존 배열의 내용을 배열로 복사하고 리스트가 새
배열과 매핑되도록 한다.


# 연결 리스트

---

작업의미는 리스트와 동일

### 원소 삽입

- x = 삽입할 원소
- prev.next = 이전 노드가 가리키는 다음 노드

```python
newNode.item = x
newNode.next = prev.next
prev.next = newNode
__numItems += 1 // 이 부분을 처음 시작하지 않는 이유는 ?
```

새 노드를 정의하고 prev.next 레퍼런스를 새 노드와 링크시킨후 prev.next를 newNode와 링크시켜 삽입을 만들어 낸다.

더미헤드노드가 있을 경우 삽입하고자 하는 노드 앞에 항상 직전 노드가 존재해 두가지의 경우로 나누지 않아도 되는 장점이 있다.

### 원소 삭제

- prev.next = 이전 노드가 가리키는 다음 원소
- next - 다음


```python
prev.next = prev.next.next
--numItems -= 1
```

prev.next가 삭제 노드 다음 노드로 건너뛰어 링크하도록 만든다.

